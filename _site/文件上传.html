<!DOCTYPE html>
<html>
<head>

    <meta charset="utf-8" />
    <title>上传图片 | juzipi</title>
    <meta name="renderer" content="webkit">
    <meta name="description" content="Blog" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <link rel="stylesheet" href="http://juzipi.github.io/blog/css/default.css" type="text/css" />
    <link rel="icon" href="http://juzipi.github.io/blog/images/logo_24.png" type="image/png">
    <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/atom.xml" />
    <script src="http://juzipi.github.io/blog/js/jquery-1.7.1.min.js" type="text/javascript"></script>
</head>
<body>


    <link rel="stylesheet" href="./js/prettify/prettify.css" />
<style type="text/css">
    body { background:#e8e8e8; }
    @media screen and (max-width: 750px){
        body { background:#fff; }
    }
    @media screen and (max-width: 1020px){
        body { background:#fff; }
    }
</style>
<div class="head">
    <a href="./">
        <img src="./images/logo_24.png" alt="logo" class="logo" />
    </a>
</div>
<div id="content">
    
    <div class="entry">
        <h1 class="entry-title"><a href="./%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0" title="上传图片">上传图片</a></h1>
        <p class="entry-date">2017-02-22</p>
        <h1>上传图片</h1>

<h2>基础知识</h2>

<h3>FormData</h3>

<blockquote><p>通过FormData对象可以组装一组用 XMLHttpRequest发送请求的键/值对。它可以更灵活方便的发送表单数据，因为可以独立于表单使用。如果你把表单的编码类型设置为multipart/form-data ，则通过FormData传输的数据格式和表单通过submit() 方法传输的数据格式相同。</p></blockquote>

<p>这是一种常见的移动端上传方式，FormData也是H5新增的 兼容性如下：</p>

<p><img src="http://juzipi.github.io/blog/images/formdata.png" alt="" /></p>

<h3>base64</h3>

<blockquote><p>Base64是一种基于64个可打印字符来表示二进制数据的表示方法。 由于2的6次方等于64，所以每6个位元为一个单元，对应某个可打印字符。 三个字节有24个位元，对应于4个Base64单元，即3个字节可表示4个可打印字符。</p></blockquote>

<p>base64可以说是很出名了，就是用一段字符串来描述一个二进制数据，所以很多时候也可以使用base64方式上传。兼容性如下：
<img src="http://juzipi.github.io/blog/images/base64.png" alt="" /></p>

<h3>Blob对象</h3>

<blockquote><p>一个 Blob对象表示一个不可变的, 原始数据的类似文件对象。Blob表示的数据不一定是一个JavaScript原生格式。 File 接口基于Blob，继承 blob功能并将其扩展为支持用户系统上的文件。</p></blockquote>

<p>简单说Blob就是一个二进制对象，是原生支持的，兼容性如下:
<img src="http://juzipi.github.io/blog/images/blob.png" alt="" /></p>

<h3>FileReader对象</h3>

<blockquote><p>FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。</p></blockquote>

<p>FileReader也就是将本地文件转换成base64格式的dataUrl。
<img src="http://juzipi.github.io/blog/images/fileReader.png" alt="" /></p>

<h3>图片上传思路</h3>

<p>准备工作都做完了，那怎样用这些材料完成一件事情呢。</p>

<p>这里要强调的是，考虑到移动端流量很贵，所以有必要对大图片进行下压缩再上传。</p>

<p>图片压缩很简单，将图片用canvas画出来，再使用canvas.toDataUrl方法将图片转成base64格式。</p>

<p>所以图片上传思路大致是：</p>

<p>1、监听一个input(type=‘file’)的onchange事件，这样获取到文件file；</p>

<p>2、将file转成dataUrl;</p>

<p>3、然后根据dataUrl利用canvas绘制图片压缩，然后再转成新的dataUrl；</p>

<p>4、再把dataUrl转成Blob；</p>

<p>5、把Blob append进FormData中；</p>

<p>6、xhr实现上传。</p>

<h3>手机兼容性问题</h3>

<p>理想很丰满，现实很骨感。
实际上由于手机平台兼容性问题，上面这套流程并不能全都支持。
所以需要根据兼容性判断。</p>

<p>经过试验发现：</p>

<p>1、部分安卓微信浏览器无法触发onchange事件（第一步就特么遇到问题）
这其实安卓微信的一个遗留问题。 查看讨论 解决办法也很简单：input标签 <input type=“file" name="image" accept="image/gif, image/jpeg, image/png”>要写成<input type="file" name="image" accept=“image/*”>就没问题了。</p>

<p>2、部分安卓微信不支持Blob对象</p>

<p>3、部分Blob对象append进FormData中出现问题</p>

<p>4、iOS 8不支持new File Constructor，但是支持input里的file对象。</p>

<p>5、iOS 上经过压缩后的图片可以上传成功 但是size是0 无法打开。</p>

<p>6、部分手机出现图片上传转换问题，请移步。</p>

<p>7、安卓手机不支持多选，原因在于multiple属性根本就不支持。</p>

<p>8、多张图片转base64时候卡顿，因为调用了cpu进行了计算。</p>

<p>9、上传图片可以使用base64上传或者formData上传</p>

<h2>上传思路修改方案</h2>

<p>经过考虑，我们决定做兼容性处理：
<img src="http://juzipi.github.io/blog/images/upImgFlow.png" alt="" />
这里边两条路，最后都是File对象append进FormData中实现上传。</p>

<h3>代码实现</h3>

<p>html</p>

<pre><code class="html">&lt;input type="file" name="image" accept=“image/*” onchange='handleInputChange'&gt;
</code></pre>

<p>js</p>

<pre><code class="javascript">// 全局对象，不同function使用传递数据
const imgFile = {};

function handleInputChange (event) {
    // 获取当前选中的文件
    const file = event.target.files[0];
    const imgMasSize = 1024 * 1024 * 10; // 10MB

    // 检查文件类型
    if(['jpeg', 'png', 'gif', 'jpg'].indexOf(file.type.split("/")[1]) &lt; 0){
        // 自定义报错方式
        // Toast.error("文件类型仅支持 jpeg/png/gif！", 2000, undefined, false);
        return;
    }

    // 文件大小限制
    if(file.size &gt; imgMasSize ) {
        // 文件大小自定义限制
        // Toast.error("文件大小不能超过10MB！", 2000, undefined, false);
        return;
    }

    // 判断是否是ios
    if(!!window.navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/)){
        // iOS
        transformFileToFormData(file);
        return;
    }

    // 图片压缩之旅
    transformFileToDataUrl(file);
}
// 将File append进 FormData
function transformFileToFormData (file) {
    const formData = new FormData();
    // 自定义formData中的内容
    // type
    formData.append('type', file.type);
    // size
    formData.append('size', file.size || "image/jpeg");
    // name
    formData.append('name', file.name);
    // lastModifiedDate
    formData.append('lastModifiedDate', file.lastModifiedDate);
    // append 文件
    formData.append('file', file);
    // 上传图片
    uploadImg(formData);
}
// 将file转成dataUrl
function transformFileToDataUrl (file) {
    const imgCompassMaxSize = 200 * 1024; // 超过 200k 就压缩

    // 存储文件相关信息
    imgFile.type = file.type || 'image/jpeg'; // 部分安卓出现获取不到type的情况
    imgFile.size = file.size;
    imgFile.name = file.name;
    imgFile.lastModifiedDate = file.lastModifiedDate;

    // 封装好的函数
    const reader = new FileReader();

    // file转dataUrl是个异步函数，要将代码写在回调里
    reader.onload = function(e) {
        const result = e.target.result;

        if(result.length &lt; imgCompassMaxSize) {
            compress(result, processData, false );    // 图片不压缩
        } else {
            compress(result, processData);            // 图片压缩
        }
    };

    reader.readAsDataURL(file);
}
// 使用canvas绘制图片并压缩
function compress (dataURL, callback, shouldCompress = true) {
    const img = new window.Image();

    img.src = dataURL;

    img.onload = function () {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = img.width;
        canvas.height = img.height;

        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

        let compressedDataUrl;

        if(shouldCompress){
            compressedDataUrl = canvas.toDataURL(imgFile.type, 0.2);
        } else {
            compressedDataUrl = canvas.toDataURL(imgFile.type, 1);
        }

        callback(compressedDataUrl);
    }
}

function processData (dataURL) {
    // 这里使用二进制方式处理dataUrl
    const binaryString = window.atob(dataUrl.split(',')[1]);
    const arrayBuffer = new ArrayBuffer(binaryString.length);
    const intArray = new Uint8Array(arrayBuffer);
    const imgFile = this.imgFile;

    for (let i = 0, j = binaryString.length; i &lt; j; i++) {
        intArray[i] = binaryString.charCodeAt(i);
    }

    const data = [intArray];

    let blob;

    try {
        blob = new Blob(data, { type: imgFile.type });
    } catch (error) {
        window.BlobBuilder = window.BlobBuilder ||
            window.WebKitBlobBuilder ||
            window.MozBlobBuilder ||
            window.MSBlobBuilder;
        if (error.name === 'TypeError' &amp;&amp; window.BlobBuilder){
            const builder = new BlobBuilder();
            builder.append(arrayBuffer);
            blob = builder.getBlob(imgFile.type);
        } else {
            // Toast.error("版本过低，不支持上传图片", 2000, undefined, false);
            throw new Error('版本过低，不支持上传图片');
        }
    }

    // blob 转file
    const fileOfBlob = new File([blob], imgFile.name);
    const formData = new FormData();

    // type
    formData.append('type', imgFile.type);
    // size
    formData.append('size', fileOfBlob.size);
    // name
    formData.append('name', imgFile.name);
    // lastModifiedDate
    formData.append('lastModifiedDate', imgFile.lastModifiedDate);
    // append 文件
    formData.append('file', fileOfBlob);

    uploadImg(formData);
}

// 上传图片
uploadImg (formData) {
    const xhr = new XMLHttpRequest();

    // 进度监听
    xhr.upload.addEventListener('progress', (e)=&gt;{console.log(e.loaded / e.total)}, false);
    // 加载监听
    // xhr.addEventListener('load', ()=&gt;{console.log("加载中");}, false);
    // 错误监听
    xhr.addEventListener('error', ()=&gt;{Toast.error("上传失败！", 2000, undefined, false);}, false);
    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
            const result = JSON.parse(xhr.responseText);
            if (xhr.status === 200) {
                // 上传成功


            } else {
                // 上传失败
            }
        }
    };
    xhr.open('POST', '/uploadUrl' , true);
    xhr.send(formData);
}
</code></pre>

<h3>延伸阅读</h3>

<p><a href="https://github.com/CommanderXL/imgResize">移动端H5图片压缩</a></p>

<p><a href="https://zhuanlan.zhihu.com/p/27627436">移动端图片上传旋转、压缩的解决方案</a></p>

<p><a href="https://www.zhihu.com/question/59267048/answer/164201665">如何比较canvas的toDataURL和toBlob方法？</a></p>

<p><a href="https://github.com/blueimp/JavaScript-Canvas-to-Blob">JavaScript-Canvas-to-Blob转换bug修复</a></p>


       
    </div>



    <div class="sidenav">
        <h2>语言</h2>
        <ul class="artical-list">
        
            <li><a href="./%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0">上传图片</a>
            
            </li>
        
            <li><a href="./%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F">图片加载的几种方式</a>
            
            </li>
        
            <li><a href="./promise">promise对象</a>
            
            </li>
        
            <li><a href="./%E8%A3%85%E9%A5%B0%E6%80%A7%E6%A8%A1%E5%BC%8F">装饰性模式</a>
            
            </li>
        
            <li><a href="./%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98">离线缓存(manifest)</a>
            
            </li>
        
            <li><a href="./%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%90%8C%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F">async、defer、preload区别</a>
            
            </li>
        
            <li><a href="./AngularJS%E5%AE%9E%E6%88%98-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5">AngularJS应用－基础概念</a>
            
            </li>
        
            <li><a href="./AngularJS-%E6%8C%87%E4%BB%A4">AngularJS应用－指令</a>
            
            </li>
        
            <li><a href="./Javascript%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0">学习笔记－设计模式 －函数</a>
            
            </li>
        
            <li><a href="./Javascript%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0">学习笔记－设计模式－基础</a>
            
            </li>
        
            <li><a href="./%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%80%83">模块化学习思考</a>
            
            </li>
        
            <li><a href="./RequireJs%E4%BD%BF%E7%94%A8">RequireJs应用</a>
            
            </li>
        
            <li><a href="./apply%E5%92%8Ccall">apply和call应用</a>
            
            </li>
        
            <li><a href="./%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81">表单验证－策略模式</a>
            
            </li>
        
            <li><a href="./%E5%86%8D%E7%9C%8B%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0">再看返回函数</a>
            
            </li>
        
        </ul>

        <h2>工具</h2>
        <ul class="artical-list">
        
            <li><a href="./ES6-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95">ES6 常用语法</a></li>
        
            <li><a href="./webpack%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8">webpack使用方法</a></li>
        
            <li><a href="./javascript%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83">前端规范的思考</a></li>
        
            <li><a href="./jekyll%E4%BD%BF%E7%94%A8">jekyll基本使用方式</a></li>
        
        </ul>

        <h2>项目沉淀</h2>
        <ul class="artical-list">
        
            <li><a href="./%E5%91%A8%E7%BA%AA%E5%BD%95">15年08月19日－周工作记录</a></li>
        
        </ul>
    </div>
</div>

<script src="./js/post.js" type="text/javascript"></script>


    
</body>
</html>
