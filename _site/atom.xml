<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>juzipi</title>
   <link href="/blog/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="/blog" rel="alternate" type="text/html" />
   <updated>2015-06-17T15:55:19+08:00</updated>
   <id>/blog</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>原型理解</title>
     <link href="http://beiyuu.com/%E5%8E%9F%E5%9E%8B%E7%90%86%E8%A7%A3"/>
     <updated>2014-12-17T00:00:00+08:00</updated>
     <id>http://beiyuu.com/原型理解</id>
     <content type="html">&lt;h1&gt;原型解析&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;什么是原型?&lt;/li&gt;
&lt;li&gt;原型的作用是什么？&lt;/li&gt;
&lt;li&gt;堆和栈的区别？&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;1.对象分类&lt;/h2&gt;

&lt;p&gt;在js中有一个概念就是一切皆是对象，但是对象也有分不同的类型
先抛出几个问题在这篇文章中去解答：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;普通对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; var o = new Object();
 var o1 = {};
 var ff=function(){}; var o2=new ff();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; var f=function(){};
 var f1=Function(&quot;sopit&quot;,&quot;alert(&#39;a&#39;)&quot;);
 function f2(){}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原型对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; //源码

 function myFun(){
     var name=&quot;juzi&quot;;
 }

 function myFunPro(){
     this.name=&quot;juzi&quot;;
     this.t=function(){
         return &quot;tt&quot;;
     }
 }

 myFunPro.prototype.title=function(){
     return &quot;biaoti&quot;;
 }

 var m=new myFun();

 myFun.prototype=m;

 var u=i=m;

 var mP=new myFunPro();

 var o=new Object();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;blockquote&gt;&lt;p&gt;顺便说几个方法&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;tpyeof 可以知道数据类型，number,object,function,undefinded,boolean,string
 判断变量是否存在，使用typeof，例如：&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    if(a){alert(&quot;a&quot;);} //有抱错信息
    if(typeof !=&quot;undefined&quot;){ alert(&quot;a&quot;); } //不会报错
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;instanceof 可以判断是否是实例，例如： a instanceof A；输出的事一个布尔值&lt;/li&gt;
&lt;/ol&gt;


&lt;blockquote&gt;&lt;/blockquote&gt;

&lt;p&gt;我想到这里可以说一下原型有什么作用了：
1. 用来继承减少空间占用&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Javascript模式学习 函数</title>
     <link href="http://beiyuu.com/Javascript%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0"/>
     <updated>2014-09-18T00:00:00+08:00</updated>
     <id>http://beiyuu.com/Javascript模式学习-函数</id>
     <content type="html">&lt;h2&gt;第四章 函数&lt;/h2&gt;

&lt;h3&gt;4.1 背景&lt;/h3&gt;

&lt;p&gt;函数是js中使用率最高的一个对象，万物皆对象。函数也不例外，只是这个对象和别的对象来说有几个特别的特性，“执行”是其中一个。&lt;/p&gt;

&lt;p&gt;另外两个特性包括：是一个一等对象，提供作用域的支持。&lt;/p&gt;

&lt;p&gt;js本身有两种作用域，一种是全局的作用域，比如window，还有一个就是局部作用域，比如函数内用var声明的作用域，函数内用if或者for等内部声明的作用域还是属于函数内部的作用域，不属于if内部的作用域。&lt;/p&gt;

&lt;p&gt;函数既然也是对象，那么就会一样会有对象的一些特性，比如有 &lt;strong&gt;属性&lt;/strong&gt; 和 &lt;strong&gt;方法&lt;/strong&gt;。&lt;/p&gt;

&lt;h4&gt;函数的中的匿名函数和命名函数之间的区别：&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;匿名函数的name属性值是一个空字符串，命名函数的name值是有值的。这是他们唯一的区别。
真正有三种术语方面的说法：带有命名的函数表达式、无名字的函数表达式、函数声明&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var add = function add(){}; //带有命名的函数表达式,末尾必须要有分号

var add = function (){};  //无名字的函数表达式

function add(){}; //函数声明，末尾可以不用分号
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;“函数直接量”这个概念一般用来表示函数表达式或者匿名函数表达式，尽量不要用，有歧义。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3&gt;4.2 函数提前&lt;/h3&gt;

&lt;p&gt;前面有过叫做变量提前的说法，也就是在运行环境中，变量始终会方便开始，即使是后面定义的也是如此。函数也有提前这一说法，因为函数也是一种对象，赋值给了变量。&lt;/p&gt;

&lt;p&gt;“函数声明”定义的函数不仅能够让函数&lt;strong&gt;定义&lt;/strong&gt;提前，还能够让声明提前。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo(){console.log(&quot;foo&quot;)}
function bar(){console.log(&quot;bar&quot;)}

function next(){

    //next 内部的foo和bar会覆盖全局的foo和bar

    console.log(typeof foo);  //function 因为foo是一个函数声明
    console.log(typeof bar);  //undefined  bar是一个无名的函数表达式

    foo();  // new foo
    bar();  //typeError: bar is not a function 

    function foo(){
        console.log(&quot;new foo&quot;)
    }
    var bar = function(){
        console.log(&quot;new bar&quot;)          
    };
    console.log(typeof bar);  //function 

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;4.3 回调模式&lt;/h3&gt;

&lt;p&gt;该模式应该是函数经常用到的一个方式，因为函数是对象，也就是说函数可以作为参数传递给另外一个函数，当给函数传入一个函数参数，并且在函数内调用了函数参数，并执行，称传入参数的函数叫回调函数，也成回调。
    function f(callback){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    callback();//执行了
}       

function cb(){
    console.log(&quot;回调&quot;);
}   

f(cb);// 回调
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;遍历节点并做一定动作，一般逻辑，把节点抛出来，并用方法隐藏，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//findNodes 方法找到节点并返回出来，
 var findNodes = function(){
    var nodeParent = document.getElementById(&quot;J_ul&quot;);
    var nodes = nodeParent.getElementsByTagName(&quot;li&quot;);
    return nodes;
 }

 //隐藏节点
var hide = function(node){
    var i=0, max = node.length; //遍历节点
    for(; i &amp;lt; max; i++){
     node[i].style.display = &quot;none&quot;;
    }
}

//显示节点
var show = function(node){
    var i=0, max = node.length; //遍历节点
    for(; i &amp;lt; max; i++){
        node[i].style.display = &quot;block&quot;;
    }
}

//执行
hide(findNodes());
show(findNodes());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里做一次操作就会遍历节点一遍，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var findNodes = function(callback){
 var nodeParent = document.getElementById(&quot;J_ul&quot;);
 var nodes = nodeParent.getElementsByTagName(&quot;li&quot;);
 var length = nodes.length;

 //判断参数callback是不是函数
 if(typeof callback !== &quot;function&quot;){
  callback = false;
 }

 while(length){
  length--;
  if(callback){
    callback(nodes[length]);// 这是回调函数可以操作部分
  }
 }

 return nodes; //还是可以返回节点
 }
 var hide = function(node){
  node.style.display = &quot;none&quot;;
  }
  var show = function(node){
  node.style.display = &quot;block&quot;;
  }

  findNodes(hide);
  findNodes(show);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 这里hide方法和show方法已经不需要再去遍历一回节点，相当于操作和需要操作的数据分离，其实有点像数据和控制器分离，这样做到findNodes方法更加&lt;code&gt;通用&lt;/code&gt;。&lt;/p&gt;

&lt;h3&gt;4.4 返回函数&lt;/h3&gt;

&lt;blockquote&gt;&lt;p&gt;函数是一个特殊变量，当有()的时候就是表示执行。执行完成之后就看有没有return，有的话就是这个函数返回出来的东西。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;函数里面还可以返回函数，但是这首先是函数执行之后的返回，也就是必须()，如果只是变量之间转换，例如：var a=fn;这样a是没有得到fn的返回值。这个只是a引用了fn。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var fn=function(){
    console.log(1);
    retunr function(){
     console.log(2);
    }
}
var a=fn;
var b=fn();
console.log(typeof a); // function,这个时候a只是fn的引用。
console.log(typeof b); // function，这个时候b是fn()执行完成之后的返回出来的function
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 如果fn执行完成之后没有返回值，即使赋值到变量上，变量也是undefind;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var fn = function(){
        console.log(1)      
    }   
    var a = fn;
    var b = fn();
    console.log(typeof a); // function,这个时候a只是fn的引用。
    console.log(typeof b); // undefined，因为fn()执行完成之后没有返回值，所以b得到对结果就是undefined;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数内部有一些私有的数据，在函数外部是访问不到，但是函数内部的函数是可以访问到，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var fn = function(){
    var count = 0; //该变量在fn外部访问不到，因为做用域的原因。
    return function(){
        count += 1; //这里可以访问到count，在函数内部。
    }
}
var a =fn();//这里执行过一次fn(),也就是初始化了一下count。
a(); //当第一次执行a()时，count已经初始化一次，因为a函数是fn里面的，所以能够访问到count变量。这个时候执行返回出来的函数。这里执行了也就是＋1。
a(); //2
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;这里有一个疑惑为什么第二次执行的时候不是1，而是2？&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;这里需要解释保存count为1的在哪里，这里就相当于开始的count=0,这是最开始的，也是执行一次就改变一次。这里可以理解count是相对返回的函数来说是一个全局变量。
例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var count = 0;
var add = function(){
    count += 1;
}
add();//这里每执行一次就改变全局变量count一次，只是前面那个例子是包含在一个函数内部。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;4.5 自定义函数&lt;/h3&gt;

&lt;p&gt;覆盖自己的函数定义，可以初始化操作一次。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var selfFn = function(){
        console.log(&quot;first&quot;);
        selfFn = funcition(){
            console.log(&quot;two&quot;);
        }
    }
    selfFn(); // first
    selfFn(); //two
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里是第一次执行的时候正常流程，并且把函数重新赋值到函数的名称，当第二次执行的时候，这个时候实际上，函数执行的内容已经覆盖开始到执行内容。函数被重定义。
函数是一个执行体，变量只是这个函数执行的引用。如果这个函数赋值给另外一个变量会怎样？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var otherFn = selfFn;
    otherFn();
    otherFn();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;4.6 自执行函数&lt;/h3&gt;

&lt;p&gt;一般这种函数是有一些只是执行一次，后面再也不执行了，并且可以保证在它里面的变量不会污染整个全局变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (function(){
        var who = &quot;juzipi&quot;;
        console.log(who);
    })() //这里括号完成表示执行

    //另外一种方式
    (function(){
    //do something
    }())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以给自执行函数加上参数，如果参数是window这样如果在浏览器的环境可以访问到全局的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var who = &#39;juzipi&#39;;
    (function(w){
        console.log(w.who); //juzipi
    })(window)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;为了通用型最好是不要用window作为参数，因为这个职能在浏览器的环境下执行&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4&gt;立即执行函数返回值&lt;/h4&gt;

&lt;p&gt;立即执行的函数也是可以返回值的，和他们函数一样。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var val = (function(){
        return 2+2;
    })()

    //可以省略括号

    var val = function(){
        return 2+2;
    }()

    //属性定义
    var obj ={
        m : (function(){
            var who = &quot;me&quot;;
            var what = &quot;call&quot;;
            return who +&quot;&quot;+what;
        })(),
        getM : function(){
            return this.m;
        }
    }

    obj.m;  //me call
    obj.getM();  //me call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里m这个属性值实际上是一个字符串，而getM是一个方法，所以要执行后得到结果。&lt;/p&gt;

&lt;h2&gt;立即初始化对象&lt;/h2&gt;

&lt;p&gt;建立一个对象，并且运行对象方法，对象字面量方式建立对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ({
        max : 2,
        min :1,
        add :function(){
            return max + min;
        },
        init : function(){
            return console.log(this.add());
        }
    }).init()
    //两种方式调用
    ({}).init();
    ({}.init());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实就是建立对象直接执行方法，如果初始化工作比较复杂，建议用这种方式，这种方式，结构比较清楚，是一次性初始化。
但是这种方式在js压缩工作工具里面不是很友好。&lt;/p&gt;

&lt;h2&gt;条件初始化&lt;/h2&gt;

&lt;p&gt;当知道某种条件在整个程序生命周期不会发生改变，这样就是对这个条件进行一次初始化操作就好，使用最多的就是浏览器特性检测。一般来说浏览器对于某种特性的支持都是固定的，不会存在变化的可能。比如对于事件的添加删除。
原来我们经常会这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var U = {
        addFn : function(el,type,fn){
            if(typeof window.addEventListener == &quot;function&quot;){
                el.addEventListener(type,fn,false);
            }else if(typeof document.attachEvent == &quot;function&quot;){
                el.attchEvnet(&quot;on&quot;+type, fn);
            }else{
                el[&quot;on&quot;+type] = fn;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这样效率不高，因为每次执行U.addFn()的时候都会去查一遍浏览器的特性，因为这个特性是固定的，所以不需要每一次都去查询一遍，只需要查询一次就可以。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var U = {
        addFn : null
        }

    if(typeof window.addEventListener == &quot;function&quot;){
        U.addFn = functon(el,type,fn){
            el.addEventListener(type,fn,false);
        }
    }esle if(typeof doucment.attachEvent == &quot;function&quot;){
        U.addFn = function(el,type,fn){
            el.attchEvent(&quot;on&quot;+type,fn)
        }
    }else{
        U.addFn = function(el,type,fn){
            el[&quot;on&quot;+type] = fn; //这里说明一下，为什么用中括号形式，而是“.”形式，因为后面那种形式不能使用字符串相加的运算
        }
    }   
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>Javascript模式学习</title>
     <link href="http://beiyuu.com/Javascript%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0"/>
     <updated>2014-09-18T00:00:00+08:00</updated>
     <id>http://beiyuu.com/Javascript模式学习</id>
     <content type="html">&lt;h1&gt;Javascript模式学习&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2&gt;变量&lt;/h2&gt;

&lt;h3&gt;1、全局变量&lt;/h3&gt;

&lt;p&gt;都知道不能随便取全局变量，在浏览器中存在一个默认的一个全局对象this，还有一个全局的属性window，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var n = 2；
this.n; //2
this.window.n; //2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想要改变全局对象名称也可以随便在任何函数里面都可以&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; var global=(function(){
    return this;
 }())
 //重新命名全局对象的名称未global;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2、函数内变量会前置&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var n=&quot;blue&quot;;
function varFront(){
    consloe.log(n); //undefined
    var n = &quot;red&quot;; 
    console.log(n); //red
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我认为的第一个会是&lt;code&gt;blue&lt;/code&gt;，但是却是&lt;code&gt;undefined&lt;/code&gt;，因为&lt;code&gt;javascript&lt;/code&gt;的引擎机制的原因，会先创建变量、函数、参数，这个阶段是一个预编译的阶段，会扫描整个上下文，再来代码运行阶段，运行里面的函数表达式。在这一段代码中因为后面创建的变量和前面的全局变量是同名的，根据刚才的原则先创建变量再运算。&lt;/p&gt;

&lt;p&gt;实际就变成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var n=&quot;blue&quot;;
function varFront(){
    var n; //提前到前面
    console.log(n);
    var n = &quot;red&quot;;
    console.log(n); //rend

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;循环&lt;/h2&gt;

&lt;h3&gt;1、for&lt;/h3&gt;

&lt;p&gt;循环也是常用的一种语法方式，在开发中避免对于DOM操作时候多次寻找耗费资源&lt;/p&gt;

&lt;p&gt;比如有一个ul下面的li集合&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for（var i = 0; i&amp;lt;li.length;i++ ）{
    //li[i];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里每一次的读取i都回去重新找一遍li，而操作DOM是非常耗资源的一个事情，应该改成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var length=li.length;
for (var i=0; i&amp;lt;length; i++){
    //li[i]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存为一个变量存起来，就读取一次减少资源消耗。
再简化一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var i,li=[];
for(i=li.length;i--){
    //li[i]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里减少一个变量，并且是减量循环，减量循环比增量循环速度更快，解释是：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;因为和零比较要比和非零数字或数组长度比较要高效的多&lt;/code&gt;?这个没有很明白；
再有就是while循环&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var li=[],i=li.length;
while(i--){
    //li[li];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2、for-in&lt;/h3&gt;

&lt;p&gt;这个用来循环对象里面的属性，这里需要了解对象属性有两种情况，一种是原生一种prototype原型立案链集成。通过方法hasOwnProperty()去过滤。
实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var man={hands:2,head:1,legs:2},i;
if(Object.prototype.clone==&quot;undefined&quot;){
    Object.prototype.clone=function(){};
}
for(i in man){
    if(man.hasOwnProperty(i)){ 
    //通过hasOwnProperyt判断clone是不是原有的属性，还是通过prototype加进来的。这里如果运行到clone，通过的值是false；
        console.log(i, &quot;:&quot;, man[i]);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;不扩充内置原型&lt;/h3&gt;

&lt;p&gt;可以扩充构造函数的prototype的原型，可以给object()，添加新的方法，但是这种方式尽量不要使用因为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不好控制，和你一起开发的人员不知道你加了这么一个原型在里面，会不会重新覆盖，&lt;/li&gt;
&lt;li&gt;一个有可能新的EC版本增加新的方法和现在的方法冲突，&lt;/li&gt;
&lt;li&gt;就像上面那个object遍历如果不加hasOwnProperty()判断会遍历出来，这个和预想的结果不一样，而加了这个需要和你合作的每个开发人员说明。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;也有情况是可以加上的，就是未来EC版本会加上这个方法，你可以预先把这个实现了，并且和团队其他人员沟通过后，给出文档。&lt;/p&gt;

&lt;h3&gt;switch&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var i=0,t=&#39;&#39;;
switch (i){
case 1:
    t=&#39;不显示&#39;;
    break;
case 0:
    t=&#39;显示&#39;;
    break;
defalut:
    t=&#39;默认显示&#39;        
}
//显示
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;代码格式规范&lt;/h2&gt;

&lt;p&gt;团队之间代码格式规范是一个团队合作的基础&lt;/p&gt;

&lt;h1&gt;3、直接量和构造函数&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;这一章原来一直都有接触，但是并没有真正理解里面的运行逻辑，通过这一章的了解需要了解里面的运行逻辑是什么。并且对于直接量和构造函数之间的区别有所收获。&lt;/p&gt;

&lt;h2&gt;3.1 对象创建的三种形式&lt;/h2&gt;

&lt;h4&gt;一种是直接量例如：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;    //这里创建了一个空对象
    var o={}；
    //也可以给这个对象直接加上方法和属性。
    var o={
        name:&quot;juzi&quot;,
        age:12,
        title:function(){
            return &quot;工程师&quot;；
        }  //这里说明一下‘,&#39;该符号，可以在现代浏览器中加上，但是在IE中会报错
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;第二种就是根据内置的Object对象创建一个实例&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var o=new Object();
//创建一个数字对象
var n=new Object(2);
console.log(n.constructor === Number); // true
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;第三种是自定义构造函数&lt;/h4&gt;

&lt;p&gt;要好理解这种方式，就是把p当做Object来对待，相当于实例了一个p对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var p=function(){
    this.age=12;
    this.name=&#39;juzi&#39;;
    this.title=function(){
        return &quot;工程师&quot;；
    }
}

var p_01=new p();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际创建的过程：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建一个空的对象｛｝；并且把它引用赋给this，继承函数原型&lt;/li&gt;
&lt;li&gt;添加属性和方法给this&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回this指向的新对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  var p = function(){
      //this={}
      this.age = 12;
      this.name = &quot;juzi&quot;;
      this.title = function(){
          return &quot;工程师&quot;
      }
      //return this;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;构造函数返回值&lt;/h4&gt;

&lt;p&gt;当用new调用一个构造函数的时候，其实调用的是这个构造函数里面的返回的对象，可以自定义返回的对象，如果没有定义的话，默认返回的事this这个对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var p ＝ function(){
        this.name=&quot;juzi&quot;;
        var that = {};
        that.name = &quot;juzipi&quot;;
        return that;
    }
    var me = new p();
    me.name;  // juzipi
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;如果返回的不是对象，是字符串，数字，布尔值，程序不会抱错，这个值会被忽略，最终还是返回this所指的对象。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4&gt;如果没有使用new&lt;/h4&gt;

&lt;p&gt;没有使用new的时候，函数内部的this实际上面指的是全局对象，如果是在浏览器里面指的就是window对象，这个并不是我们想要的效果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var p = function(){
        this.name = &quot;juzi&quot;;
    }
    var me = new p(); // suc
    var me = p();
    console.log(typeof me);  //undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以这就需要我们在用函数命名的时候，有一个约定，不然自己搞混了，函数开始字母用小写（myFunction），构造函数就用大写（MyFunction）。&lt;/p&gt;

&lt;h4&gt;使用that&lt;/h4&gt;

&lt;p&gt;为了避免忘记new等一些错误写法，可以全部返还that这个对象，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var p = function(){
        var that = {}
        that.name = &quot;juzi&quot;;
        return that;
    }
    var me = p();
    me.name; //juzi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候就不会发生错误，能够得到里面的值，但是这个有一个问题，不能继承方法的原型。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;这里的that可以是任何的字&lt;/p&gt;&lt;/blockquote&gt;
</content>
   </entry>
   
   <entry>
     <title>模块化学习思考</title>
     <link href="http://beiyuu.com/%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%80%83"/>
     <updated>2014-09-05T00:00:00+08:00</updated>
     <id>http://beiyuu.com/学习思考</id>
     <content type="html">&lt;h1&gt;模块化思考&lt;/h1&gt;

&lt;p&gt;最近看了一些模块化相关的库或者是文章，本文的目的也是给自己里一个头绪，到底怎样才能真正推行到团队里面的模块化，这个概念说了这么久，现在这两年开始真正推行起来。&lt;/p&gt;

&lt;p&gt;作为一个由美工转过来的前端，我知道我自己在编程这一块是我的弱项。不过这两年发现前端慢慢转到工程化这个阶段，在这方面我还是能够提升。&lt;/p&gt;

&lt;p&gt;原来我一直说是自动化其实最近，我越来越感觉应该是一个工程化的概念，甚至可以说是一个系统工程。&lt;/p&gt;

&lt;p&gt;原来我们的初级阶段的模块化，按照功能模块把，html和css分割开来，&lt;/p&gt;

&lt;p&gt;HTML：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul class=&#39;Module&#39;&amp;gt;
    &amp;lt;li&amp;gt;Tab 1&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;Tab 2&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;Tab 3&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CSS：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.Module li{..}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么后面调用这个CSS和HTML就组成一个模块，但是这个没有解决几个问题，如果里面有交互牵涉到js怎么模块化，这里只是CSS和HTML。&lt;/p&gt;

&lt;p&gt;后面用到百度的fis，这个工具我自己的给它的定位就是管理并且发布静态资源。解决的是静态资源的问题，&lt;/p&gt;

&lt;h3&gt;js加载模块化&lt;/h3&gt;

&lt;p&gt;在js加载这一块目前国内说得比较多的是Requery.js和seajs这两个加载库，给我感觉作用差不多，只不过require和seajs神明模块的方式不同&lt;/p&gt;

&lt;h3&gt;require&lt;/h3&gt;

&lt;p&gt;申明方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,function(&quot;modelA&quot;,&quot;modelB&quot;,&quot;modelC&quot;){

})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用方式：&lt;/p&gt;

&lt;h3&gt;seajs&lt;/h3&gt;

&lt;p&gt;申明方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports, module) {

// 引用moduleA.js文件
var module=require(./moduelA);


});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用方式：&lt;/p&gt;

&lt;p&gt;但是这种模块加载会演变成一个问题，每一个模块都是一个js文件，一个项目可能会有几十个文件，这样导致浏览器请求增加太多，对性能有所影响，这时候就需要合并js文件。&lt;/p&gt;

&lt;p&gt;模块化加载》合并文件》这样也会产生一个问题，根据页面的功能不同，怎样加载不同页面并且还不会重复加载。
比如&lt;code&gt;a.html&lt;/code&gt;页面功能有&lt;code&gt;a.js&lt;/code&gt; &lt;code&gt;b.js&lt;/code&gt; &lt;code&gt;c.js&lt;/code&gt;,合并成一个文件.&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>VPS环境搭建详解 (Virtualenv+Gunicorn+Supervisor+Nginx)</title>
     <link href="http://beiyuu.com/vps-config-python-vitrualenv-flask-gunicorn-supervisor-nginx"/>
     <updated>2014-01-25T00:00:00+08:00</updated>
     <id>http://beiyuu.com/vps-config-python-vitrualenv-flask-gunicorn-supervisor-nginx</id>
     <content type="html">&lt;p&gt;新用户注册购买&lt;a href=&quot;https://www.digitalocean.com/?refcode=f95f7297ed94&quot; title=&quot;DigitalOcean&quot;&gt;DigitalOcean&lt;/a&gt;的VPS，使用优惠码&lt;code&gt;2014SSD&lt;/code&gt;（或请尝试&lt;code&gt;10TOSHIP&lt;/code&gt;）有$10赠送，可用两个月。DO采取丧心病狂的低价竞争策略，每月$5即可享用全功能的SSD硬盘VPS，具体去看看&lt;a href=&quot;https://www.digitalocean.com/?refcode=f95f7297ed94&quot; title=&quot;DigitalOcean&quot;&gt;这里&lt;/a&gt;吧。&lt;/p&gt;

&lt;p&gt;注册，选择套餐、机房、系统(我选默认Ubuntu 12)，付款成功，可以开始配置了。&lt;/p&gt;

&lt;p&gt;我们目标实现一个支持多个独立域名网站的线上Python环境，这会用到&lt;a href=&quot;http://www.virtualenv.org/en/latest/&quot; title=&quot;Virtualenv&quot;&gt;Virtualenv&lt;/a&gt;， &lt;a href=&quot;http://flask.pocoo.org/docs/&quot; title=&quot;Flask&quot;&gt;Flask&lt;/a&gt;， &lt;a href=&quot;http://gunicorn.org/&quot; title=&quot;Gunicorn&quot;&gt;Gunicorn&lt;/a&gt;， &lt;a href=&quot;http://supervisord.org/&quot; title=&quot;Supervisor&quot;&gt;Supervisor&lt;/a&gt;， &lt;a href=&quot;http://nginx.com/&quot; title=&quot;Nginx&quot;&gt;Nginx&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;配置用户环境&lt;/h2&gt;

&lt;p&gt;因为要跑多个站，所以最好将他们完全隔离，每个站对应一个用户，于是我们有了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; User        Site

 bob         dylan     ##bob用户有一个dylan的站
michael     jackson    ##michael用户有一个jackson的站
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注册成功后，会收到DO发来的&lt;code&gt;root&lt;/code&gt;账户的密码邮件，&lt;code&gt;ssh root@你的IP地址&lt;/code&gt;登录上去开始添加用户。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##推荐安装zsh作为默认shell
sudo apt-get update
sudo apt-get install zsh

##安装oh-my-zsh插件
cd ~/.
##自动安装脚本
wget --no-check-certificate https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh

##添加用户bob
##参数-d：指定用户目录
##参数-m：如果目录不存在则创建
##参数-s：只用用户使用的 shell
useradd bob -d /home/bob -m -s /bin/zsh

#添加用户michael
useradd michael -d /home/michael -m -s /bin/zsh

##以上参数也可以修改passwd文件来调整
sudo vim /etc/passwd

##sudo和用户组管理在
visudo
sudo vim /etc/sudoers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新增用户之后，需要解锁：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##为新增用户设置一个初始密码即可解锁
passwd bob
passwd michael
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用ssh-keygen建立信任关系可以方便登录管理：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##本地机器
##会在~/.ssh目录下生成秘钥文件id_rsa、id_rsa.pub
ssh-keygen -t [rsa|dsa]

##复制公钥文件id_rsa.pub
scp ~/.ssh/id_rsa.pub bob@digitalocean:~/.ssh

##VPS上，添加本地机器的信任关系
cd ~/.ssh
cat id_rsa.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys

##OK，从本地机器登录到VPS的bob用户就不需要密码了
##同理，也可以添加到michael用户的.ssh目录下
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多资料可以阅读：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.chinaunix.net/old_jh/4/438660.html&quot; target=&quot;_blank&quot; class=&quot;external&quot;&gt;Linux的用户和用户组管理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://sofish.de/1685&quot; target=&quot;_blank&quot; class=&quot;external&quot;&gt;把 Mac 上的 bash 换成 zsh&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://leeiio.me/bash-to-zsh-for-mac/&quot; target=&quot;_blank&quot; class=&quot;external&quot;&gt;zsh – 给你的Mac不同体验的Terminal&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/kongqz/article/details/6338690&quot; target=&quot;_blank&quot; class=&quot;external&quot;&gt;ssh-keygen的使用方法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/03/server_setup.html&quot; target=&quot;_blank&quot; class=&quot;external&quot;&gt;Linux服务器的初步配置流程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/03/server_setup.html&quot; target=&quot;_blank&quot; class=&quot;external&quot;&gt;Linux服务器的初步配置流程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;为每个APP创建Virtualenv&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.virtualenv.org/en/latest/&quot; title=&quot;Virtualenv&quot;&gt;Virtualenv&lt;/a&gt;可以为每个Python应用创建独立的开发环境，使他们互不影响，Virtualenv能够做到：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在没有权限的情况下安装新套件&lt;/li&gt;
  &lt;li&gt;不同应用可以使用不同的套件版本&lt;/li&gt;
  &lt;li&gt;套件升级不影响其他应用&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;安装Virtualenv&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##先安装Python的包管理pip
sudo apt-get install pip

##用pip安装virtualenv
sudo pip install virtualenv

##建议用bob用户登录操作
##bob用户创建dylan的virtualenv
cd /home/bob
virtualenv dylan

##激活virtualenv
cd /home/bob/dylan
source ./bin/activate

##取消激活只需
deactivate

##michael用户如法炮制即可
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;安装Flask&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://flask.pocoo.org/docs/&quot; title=&quot;Flask&quot;&gt;Flask&lt;/a&gt;是Python流行的一个web框架，但是Flask比Django轻量了许多，使用更加直观，这里并不展开讲Flask的细节，当做一个Hello Wordld来用就好了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##安装Flask
##依然在virtualenv activate的环境下
pip install Flask

##根目录下
vim runserver.py

##写入Flask的Hello World
from flask import Flask
app = Flask(__name__)

@app.route(&#39;/&#39;)
def hello_world():
    return &#39;Hello World!&#39;

    if __name__ == &#39;__main__&#39;:
        app.run()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写入之后，如果在本地机器上可以运行&lt;code&gt;python runserver.py&lt;/code&gt;，然后打开&lt;code&gt;127.0.0.1:5000&lt;/code&gt;看到Hello World!了，但在VPS，这样不行，等待后面配置吧。&lt;/p&gt;

&lt;h2&gt;安装Gunicorn&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://gunicorn.org/&quot; title=&quot;Gunicorn&quot;&gt;Gunicorn&lt;/a&gt;是用于部署WSGI应用的，任何支持WSGI的都可以，虽说直接&lt;code&gt;python runserver.py&lt;/code&gt;这样网站也能跑起来，但那是方便开发而已，在线上环境，还是需要更高效的组件来做。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##安装Gunicorn
##依然在Virtualenv环境下
pip install gunicorn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gunicorn的配置是必须的，因为我们要上两个独立的站，所以不能都用默认的配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##在bob的dylan项目下
cd /home/bob/dylan
vim gunicorn.conf

##文件内写入以下内容
##指定workers的数目，使用多少个进程来处理请求
##绑定本地端口
workers = 3
bind = &#39;127.0.0.1:8000&#39;

##在michael的jackson项目下
cd /home/michael/jackson
vim gunicorn.conf

##写入文件内容
##与dylan的端口要不一样
workers = 3
bind = &#39;127.0.0.1:8100&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终的目录结构应该是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/home/
└── bob  //用户目录
│   ├── logs
│   └── dylan  //项目目录
│       ├── bin
│       │   ├── activate
│       │   ├── easy_install
│       │   ├── gunicorn
│       │   ├── pip
│       │   └── python
│       ├── include
│       │   └── python2.7 -&amp;gt; /usr/include/python2.7
│       ├── lib
│       │   └── python2.7
        ├── local
│       │   ├── bin -&amp;gt; /home/shenye/shenyefuli/bin
│       │   ├── include -&amp;gt; /home/shenye/shenyefuli/include
│       │   └── lib -&amp;gt; /home/shenye/shenyefuli/lib
│       │
│       │ //以上目录是Virtualenv生成的
│       ├── gunicorn_conf.py  //Gunicorn的配置文件
│       └── runserver.py  //hello_world程序
│
│
└── michael  //用户目录
    ├── logs
    └── jackson //项目目录
        ├── bin
        │   ├── activate
        │   ├── easy_install
        │   ├── gunicorn
        │   ├── pip
        │   └── python
        ├── include
        │   └── python2.7 -&amp;gt; /usr/include/python2.7
        ├── lib
        │   └── python2.7
        ├── local  //以上这些文件都是Virtualenv需要的
        │   ├── bin -&amp;gt; /home/shenye/shenyefuli/bin
        │   ├── include -&amp;gt; /home/shenye/shenyefuli/include
        │   └── lib -&amp;gt; /home/shenye/shenyefuli/lib
        │
        │ //以上目录是Virtualenv生成的
        ├── gunicorn_conf.py  //Gunicorn的配置文件
        └── runserver.py  //hello_world程序
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;安装Supervisor&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://supervisord.org/&quot; title=&quot;Supervisor&quot;&gt;Supervisor&lt;/a&gt;可以同时启动多个应用，最重要的是，当某个应用Crash的时候，他可以自动重启该应用，保证可用性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##安装Supervisor
##sudo安装
sudo apt-get install supervisor

##启动服务
sudo service supervisor start
##终止服务
sudo service supervisor stop
##也可以直接kill pid
ps -A | grep supervisor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改了程序代码，或者修改了配置，需要手动重启supervisor服务，尤其是摸不着头脑的错误的时候，重启最能解决问题！&lt;/p&gt;

&lt;p&gt;安装好之后，开始配置各应用的supervisor服务：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##supervisor的配置文件位置在：
/etc/supervisor/supervisor.conf

##为了代码好看一些，我们分别放置各项目的配置文件
##新建bob的dylan项目配置文件
touch /etc/supervisor/conf.d/dylan.conf

##文件内容
[program:dylan]
##注意项目目录和gunicorn的配置文件地址
command=/home/bob/dylan/bin/gunicorn runserver:app -c /home/bob/dylan/gunicorn.conf
directory=/home/bob/dylan
user=bob
autostart=true
autorestart=true
##log文件的位置
stdout_logfile=/home/bob/logs/gunicorn_supervisor.log


##新建michael的jackson项目配置文件
touch /etc/supervisor/conf.d/jackson.conf

##文件内容
[program:jackson]
command=/home/michael/jackson/bin/gunicorn runserver:app -c /home/michael/jackson/gunicorn.conf
directory=/home/michael/jackson
user=michael
autostart=true
autorestart=true
stdout_logfile=/home/michael/logs/gunicorn_supervisor.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写好配置之后：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##重新读取配置
sudo supervisorctl reread

##启动服务
sudo supervisorctl start dylan
sudo supervisorctl start jackson

##停止服务
sudo supervisorctl stop dylan
sudo supervisorctl stop jackson

##有问题就重启supervisor的总服务
sudo service supervisor stop
sudo service supervisor start
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;安装Nginx&lt;/h2&gt;

&lt;p&gt;有了&lt;a href=&quot;http://gunicorn.org/&quot; title=&quot;Gunicorn&quot;&gt;Gunicorn&lt;/a&gt;、&lt;a href=&quot;http://supervisord.org/&quot; title=&quot;Supervisor&quot;&gt;Supervisor&lt;/a&gt;，本地的环境的算是搭好了，但是我们需要让VPS上的网站从外网可以访问，这时候需要Nginx。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://nginx.com/&quot; title=&quot;Nginx&quot;&gt;Nginx&lt;/a&gt;是轻量级、性能强、占用资源少，能很好的处理高并发的反向代理软件，是我们的不二选择：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##安装Nginxx
sudo apt-get install nginx

##启动服务
sudo service nginx start

##查看VPS的IP地址
ifconfig eth0 | grep inet | awk &#39;{ print $2  }&#39;

##重启和暂停服务
sudo service nginx restart
sudo service nginx stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nginx的配置文件和Supervisor类似，不同的程序可以分别配置，然后被总配置文件include：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##Nginx的配置文件地址
/etc/nginx/nginx.conf

##新建bob的dylan项目配置文件
##在sites-available目录下
touch /etc/nginx/sites-available/dylan.com

##文件内容
server {
        listen   80;             //端口
        server_name dylan.com;   //访问域名

        root /home/bob/dylan/;
        access_log /home/bob/logs/access.log;
        error_log /home/bob/logs/access.log;

        location / {
                proxy_set_header X-Forward-For $proxy_add_x_forwarded_for;
                proxy_set_header Host $http_host;
                proxy_redirect off;
                if (!-f $request_filename) {
                        proxy_pass http://127.0.0.1:8000;  //这里是dylan的gunicorn端口
                        break;
                }
        }
}


##michael的jackson项目
touch /etc/nginx/sites-available/jackson.com

##文件内容
server {
        listen   80;               //端口
        server_name jackson.com;   //访问域名

        root /home/michael/jackson/;
        access_log /home/michael/logs/access.log;
        error_log /home/michael/logs/access.log;

        location / {
                proxy_set_header X-Forward-For $proxy_add_x_forwarded_for;
                proxy_set_header Host $http_host;
                proxy_redirect off;
                if (!-f $request_filename) {
                        proxy_pass http://127.0.0.1:8100;  //这里是jackson的gunicorn端口
                        break;
                }
        }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置完成之后，&#39;sudo service nginx restart&#39;重启一下服务，再配置一下本地的Hosts，打开浏览器应该就能看到了。&lt;/p&gt;

&lt;h2&gt;完成&lt;/h2&gt;

&lt;p&gt;至此，一个完整的环境搭建就完成了，推荐试用&lt;a href=&quot;https://www.digitalocean.com/?refcode=f95f7297ed94&quot; title=&quot;DigitalOcean&quot;&gt;DigitalOcean&lt;/a&gt;的VPS看看，&lt;code&gt;2014SSD&lt;/code&gt;（或请尝试&lt;code&gt;10TOSHIP&lt;/code&gt;）的优惠码也可以试试看看有没有过期哦~&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>CSS3动画详解</title>
     <link href="http://beiyuu.com/css3-animation"/>
     <updated>2013-08-24T00:00:00+08:00</updated>
     <id>http://beiyuu.com/css3-animation</id>
     <content type="html">&lt;h2&gt;CSS3动画&lt;/h2&gt;

&lt;p&gt;新增有人认为CSS动画是做了js的事情，较真起来也算，只是已经抢占许多年了，早些年要实现鼠标滑过链接变色的基本效果，需要动用Java Applet，后来只需给HTML元素加事件&lt;code&gt;onclick=changecolor()&lt;/code&gt;，再之后正如你所知，只要写&lt;code&gt;:hover&lt;/code&gt;、&lt;code&gt;:focus&lt;/code&gt;这样的伪类即可，同样的，现在有了CSS3动画。&lt;/p&gt;

&lt;h4&gt;CSS3动画的优势：&lt;/h4&gt;

&lt;ul&gt;
    &lt;li&gt;写起来非常方便，不会js也没问题&lt;/li&gt;
    &lt;li&gt;有些动画js也不能很好的胜任，比如让一个元素在二维、三维空间旋转&lt;/li&gt;
    &lt;li&gt;运行效果流畅，让浏览器去优化性能&lt;/li&gt;
    &lt;li&gt;浏览器从底层优化动画序列，例如当tab不可见的时候，降低更新的频率提高整体性能&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;劣势：&lt;/h4&gt;

&lt;ul&gt;
    &lt;li&gt;CSS3动画应用的范围还是有限&lt;/li&gt;
    &lt;li&gt;兼容性：对于增强体验的Feature来说，可以无视&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;可以做动画效果的属性&lt;/h3&gt;

&lt;p&gt;理论上来说，任何单独的CSS属性都可以做动画的效果，比如：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;width&lt;/code&gt;：10px 到 100px&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;padding&lt;/code&gt;：0px 到 20px&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;color&lt;/code&gt;：#F00 到 #00F&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;top&lt;/code&gt;：0px 到 10px&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;border-radius&lt;/code&gt;：3px 到 8px&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;transform&lt;/code&gt;：rotate(0deg) 到 ratate(45deg)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;你也可以给&lt;code&gt;red&lt;/code&gt;、&lt;code&gt;blue&lt;/code&gt;这样的赋值的颜色属性加transition或animation，它会被自动转化为对应的RGB值。&lt;/p&gt;

&lt;h3&gt;不可以做动画效果的属性&lt;/h3&gt;

&lt;p&gt;看下面这些例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#container p {
    display: none;
    transition: all 3s ease;
}

#container:hover p {
    display: block;
}

/**********************/

#container p {
    height: 0px;
    transition: all 3s ease;
}

#container:hover p {
    height: auto;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;属性从无到有或到不确定值，动画效果不会生效，因为浏览器不知道如何去做，对于元素从无到有，你可以选择&lt;code&gt;opacity&lt;/code&gt;属性来处理。&lt;/p&gt;

&lt;h2&gt;CSS3 Transition&lt;/h2&gt;

&lt;p&gt;Transition是被用到最多的也是最简单的CSS3动画类型。如果要做一个10px宽的蓝色元素在3s后变成一个100px宽的红色元素的效果，Transition可以平滑实现，你只需要声明起始和终止这两个状态。&lt;/p&gt;

&lt;p&gt;Transition的触发也很简单，可以用&lt;code&gt;:hover&lt;/code&gt;、&lt;code&gt;:focus&lt;/code&gt;这样的伪类来触发，也可以通过改变元素的样式来触发。&lt;/p&gt;

&lt;h3&gt;transition的属性&lt;/h3&gt;

&lt;h4&gt;transition-property&lt;/h4&gt;

&lt;p&gt;transition-property用来声明transition会被应用到的属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#container p.one {
    transition-property: color;
}

#container p.two {
    transition-property: width;
}

#container p.three {
    transition-property: color, width;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你想应用到所有属性，那可以简单写作&lt;code&gt;all&lt;/code&gt;，也可以通过&lt;code&gt;none&lt;/code&gt;来关闭transition。&lt;/p&gt;

&lt;h4&gt;transition-duration&lt;/h4&gt;

&lt;p&gt;transition-duration用来声明动画持续的时长，可以是s也可以是ms&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#container p.one {
    transition-duration: 3s;
}

#container p.two {
    transition-duration: 3000ms;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;transition-timing-function&lt;/h4&gt;

&lt;p&gt;transition-timing-function声明了动画的缓动类型，有下面几个选项：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;ease&lt;/code&gt;：默认项，动画效果慢慢开始然后加速，到中点后再减速最后缓慢到达终点&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;ease-in-out&lt;/code&gt;：与ease类似，加减速更柔和一些&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;ease-in&lt;/code&gt;：开始比较慢，但是加速和停止曲线比较陡峭&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;ease-out&lt;/code&gt;：开始较快，然后缓慢停止&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;linear&lt;/code&gt;：线性平均速率，通常在color和opacity属性的变化上&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;最后，还有&lt;code&gt;cubic-bezier&lt;/code&gt;函数，可以自己创造更多更优美的缓动类型。&lt;/p&gt;

&lt;h4&gt;transition-delay&lt;/h4&gt;

&lt;p&gt;transition-delay声明了动画延迟开始的时间，很容易理解&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#container p.one {
    transition-delay: 0.5s;
}

#container p.two {
    transition-delay: 500ms;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;transition简写&lt;/h3&gt;

&lt;p&gt;上面介绍了transition的属性，他们也可以合并成一项，省去了许多拼写，当然也别忘记浏览器前缀：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#container p {
    transition-property: all;
    transition-duration: 3s;
    transition-timing-function: ease-in-out;
    transition-delay: 0.5s;
}


#element {
    /* starting state styles */
    color: #F00;
    -webkit-transition: all 3s ease-in-out 0.5s;
    transition: all 3s ease-in-out 0.5s;
}

#element:hover {
    /* ending state styles */
    color: #00F;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;transition的高级用法&lt;/h3&gt;

&lt;h4&gt;不同的transition效果&lt;/h4&gt;

&lt;p&gt;看这样的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p#animate {
    color: #ff6;
    transition: all 3s ease-in-out 0.5s;
}

p#animate:hover {
    color: #0f0;
    transform: scale(4);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个例子中，当鼠标hover，元素在0.5s之后在3s内放大四倍，鼠标移开，需要同样的时间回到原来的状态。如果想要不同的效果，可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p#animate {
    color: #ff6;
    transition: all 0.5s ease-in-out;
}

p#animate:hover {
    color: #0f0;
    transform: scale(4);
    transition: all 3s ease-in-out 0.5s;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;多个transition&lt;/h4&gt;

&lt;p&gt;需要给多个transition指定不同的效果时，&lt;code&gt;all&lt;/code&gt;属性解决不了，可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p#animate {
    width: 10em;
    background-color: #F00;
    border-radius: 5px;
    transition-property: width, border-radius, background-color;
    transition-duration: 1s, 2s;
    transition-timing-function:  ease, ease-out, linear;
}

p#animate:hover {
    width: 20em;
    background-color: #00F;
    border-radius: 50%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意其中的&lt;code&gt;transition-duration&lt;/code&gt;只写了两个，那么第三个&lt;code&gt;transition-property&lt;/code&gt;属性&lt;code&gt;background-color&lt;/code&gt;就用循环到第一个，也就是说他的&lt;code&gt;transition-duration&lt;/code&gt;值是&lt;code&gt;1s&lt;/code&gt;。&lt;/p&gt;

&lt;h3&gt;transition示例&lt;/h3&gt;

&lt;div id=&quot;transition1&quot;&gt;
#transition1 {&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;width:350px;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;background-color:#1abc9c;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;transition-propety:width,background-color;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;transition-duration:.5s, 1s;&lt;br&gt;
}&lt;br&gt;
#transition1:hover {&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;width:450px;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;background-color:#8e44ad;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;transition-duration:.5s, 3s;&lt;br&gt;
}&lt;br&gt;
&lt;/div&gt;


&lt;h2&gt;CSS3 Animation&lt;/h2&gt;

&lt;h3&gt;Animation和Transition的不同&lt;/h3&gt;

&lt;ul&gt;
    &lt;li&gt;和transition一样都可以定义开始和结束状态，但是animation还可以指定更确定的中间状态&lt;/li&gt;
    &lt;li&gt;animation可以像transition一样被触发，也可以自动运行&lt;/li&gt;
    &lt;li&gt;animation可以无限循环的运行下去，也可以指定运行的次数&lt;/li&gt;
    &lt;li&gt;animation可以在顺序运行也可以反向运行&lt;/li&gt;
    &lt;li&gt;animatino写起来稍麻烦些，但是依然比js简单许多&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;定义keyframes&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;@keyframes colorchange {
    0%   { background-color: #00F; /* from: blue */ }
    25%  { background-color: #F00; /* red        */ }
    50%  { background-color: #0F0; /* green      */ }
    75%  { background-color: #F0F; /* purple     */ }
    100% { background-color: #00F; /* to: blue   */ }
}

@-webkit-keyframes colorchange {
    0%   { background-color: #00F; /* from: blue */ }
    25%  { background-color: #F00; /* red        */ }
    50%  { background-color: #0F0; /* green      */ }
    75%  { background-color: #F0F; /* purple     */ }
    100% { background-color: #00F; /* to: blue   */ }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个例子中，只是定义了&lt;code&gt;background-color&lt;/code&gt;这一个属性，如有需要，可以换做其他。对于&lt;code&gt;0%&lt;/code&gt;这个也可以用&lt;code&gt;from&lt;/code&gt;关键字来替代，同样的可以用&lt;code&gt;to&lt;/code&gt;来代替&lt;code&gt;100%&lt;/code&gt;，过渡状态，你可以定义任何百分比，类似&lt;code&gt;12.5%&lt;/code&gt;这样的也可以，不过就不用给自己找麻烦了吧。浏览器的&lt;code&gt;prefix&lt;/code&gt;也不能少。&lt;/p&gt;

&lt;h3&gt;应用到元素&lt;/h3&gt;

&lt;p&gt;将&lt;code&gt;animation&lt;/code&gt;应用到元素的属性写法，和&lt;code&gt;transition&lt;/code&gt;差不太多，顺序都一致，就不在一个个参数重复说明，直接看代码吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#myelement {
    animation-name: colorchange; /**这里引用了前面定义的动画**/
    animation-duration: 5s;
    animation-timing-function: linear;
    animation-delay: 1s;
    animation-iteration-count: infinite;
    animation-direction: alternate;
}

/****简写****/
#myelement {
    -webkit-animation: colorchange 5s linear 1s infinite alternate;
    animation: colorchange 5s linear 1s infinite alternate;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;animation-iteration-count&lt;/code&gt;用来指定动画循环的次数，无限循环用&lt;code&gt;infinite&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;animation-direction有四个值：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;normal&lt;/code&gt;：默认，从0%执行到100%&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;reverse&lt;/code&gt;：动画从100%执行到0%&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;alternate&lt;/code&gt;：动画在0%到100%之间往复执行&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;alternate-reverse&lt;/code&gt;与&lt;code&gt;alternate&lt;/code&gt;一致，不过是从100%开始&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Animation示例&lt;/h3&gt;

&lt;div id=&quot;ani1&quot;&gt;Animate color&lt;/div&gt;


&lt;h2&gt;CSS3 Transform&lt;/h2&gt;

&lt;p&gt;有了&lt;code&gt;transition&lt;/code&gt;和&lt;code&gt;animation&lt;/code&gt;之后，就可以做出些漂亮的动画效果，如果再搭配&lt;code&gt;transform&lt;/code&gt;这一CSS3动画利器，就更出彩了。&lt;/p&gt;

&lt;h3&gt;CSS3 2D Transform&lt;/h3&gt;

&lt;p&gt;运用CSS3 2D Transform的技术，可以更自由轻松的来修饰HTML元素。CSS3 2D Transform的基本方法有下面这些：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;translate()&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;rotate()&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;scale()&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;skew()&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;matrix()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;Translate&lt;/h4&gt;

&lt;p&gt;使用&lt;code&gt;translate()&lt;/code&gt;方法，可以将HTML元素在x-y轴平面上做位移，且不会影响到其他元素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div{
    -webkit-transform: translate(20px,20px);
    -moz-transform: translate(20px,20px);
    -o-transform: translate(20px,20px);
    transform: translate(20px,20px);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果如下：&lt;/p&gt;

&lt;div id=&quot;translate1&quot;&gt;
&lt;div id=&quot;trans-inner1&quot;&gt;Normal Div&lt;/div&gt;
&lt;div id=&quot;trans-inner2&quot;&gt;transform:tranlated(40px, 40px)&lt;/div&gt;
&lt;/div&gt;


&lt;h4&gt;Rotate&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;rotate()&lt;/code&gt;方法可以将元素按照时钟方向旋转，参数可以是&lt;code&gt;0deg&lt;/code&gt;到&lt;code&gt;360deg&lt;/code&gt;，也是在x-y轴平面，示例如下：&lt;/p&gt;

&lt;div id=&quot;rotate1&quot;&gt;
&lt;div id=&quot;rota-inner1&quot;&gt;Normal Div&lt;/div&gt;
&lt;div id=&quot;rota-inner2&quot;&gt;transform:rotate(-30deg)&lt;/div&gt;
&lt;/div&gt;


&lt;h4&gt;Scale&lt;/h4&gt;

&lt;p&gt;和名字的一样，&lt;code&gt;scale()&lt;/code&gt;方法用来放大一个元素，依然是在x-y轴平面，看示例：&lt;/p&gt;

&lt;div id=&quot;scale1&quot;&gt;
    &lt;div id=&quot;sca-inner1&quot;&gt;Normal Div&lt;/div&gt;
    &lt;div id=&quot;sca-inner2&quot;&gt;transform:scale(1.5,1.3)&lt;/div&gt;
&lt;/div&gt;


&lt;h4&gt;Skew&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;skew()&lt;/code&gt;方法可以将元素按照指定参数进行扭曲，你需要指定x、y轴的扭曲角度，看示例：&lt;/p&gt;

&lt;div id=&quot;skew1&quot;&gt;
&lt;div id=&quot;sk-inner1&quot;&gt;Normal Div&lt;/div&gt;
&lt;div id=&quot;sk-inner2&quot;&gt;transform:skew(30deg,0)&lt;/div&gt;
&lt;/div&gt;


&lt;h4&gt;Matrix&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;matrix()&lt;/code&gt;方法是以上所有2D效果的方法的总和，写法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div{
    transform: matrix(a,b,c,d,tx,ty);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本质上&lt;code&gt;scale&lt;/code&gt;、&lt;code&gt;skew&lt;/code&gt;、&lt;code&gt;rotate&lt;/code&gt;、&lt;code&gt;translate&lt;/code&gt;的效果都是通过&lt;code&gt;matrix&lt;/code&gt;实现的，&lt;code&gt;tx&lt;/code&gt;、&lt;code&gt;ty&lt;/code&gt;表示位移量，关于&lt;code&gt;matrix&lt;/code&gt;方法更详细的介绍可以参考这里：&lt;a href=&quot;http://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/&quot;&gt;理解CSS3 transform中的Matrix(矩阵)&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;CSS3 3D Transform&lt;/h3&gt;

&lt;p&gt;了解了2D Transform之后，3D Transform的概念也不会太难，他给HTML元素在x-y平面加上了z轴，我们一个个来看看：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;translate3d(tx,ty,tz)&lt;/code&gt;：他定义了一个3D的位移方法，增加了z轴的偏移量&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;translateZ(tz)&lt;/code&gt;：这个方法只在Z轴偏移，与&lt;code&gt;translateX()&lt;/code&gt;和&lt;code&gt;translateY()&lt;/code&gt;相似&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;scale3d(sx,sy,sz)&lt;/code&gt;：在原有的&lt;code&gt;scale&lt;/code&gt;方法上增加了z轴的参数&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;scaleZ(sz)&lt;/code&gt;：同理，只放大z轴，与&lt;code&gt;scaleX()&lt;/code&gt;和&lt;code&gt;scaleY()&lt;/code&gt;类似&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;rotate3d(rx,ry,rz)&lt;/code&gt;：将元素以给定参数的某一个轴方向旋转&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;rotateX(angle)，rotateY(angle)&lt;/code&gt;和&lt;code&gt;rotateZ(angle)&lt;/code&gt;：只按照某一个轴旋转，&lt;code&gt;rotate3d(1,0,0,30deg)&lt;/code&gt;相当于&lt;code&gt;rotateX(30deg)&lt;/code&gt;，其他类推。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;来看看例子：&lt;/p&gt;

&lt;div class=&quot;transform-con&quot;&gt;
&lt;div id=&quot;trans-3&quot; class=&quot;inner&quot;&gt;
width:100%;&lt;br&gt;
height:100%;&lt;br&gt;
transform: translateZ(-200px);
&lt;/div&gt;
&lt;/div&gt;




&lt;div class=&quot;transform-con&quot;&gt;
&lt;div id=&quot;trans-31&quot; class=&quot;inner&quot;&gt;
width:100%;&lt;br&gt;
height:100%;&lt;br&gt;
transform: translateZ(100px);
&lt;/div&gt;
&lt;/div&gt;




&lt;div class=&quot;transform-con&quot;&gt;
&lt;div id=&quot;rotate-31&quot; class=&quot;inner&quot;&gt;
width:100%;&lt;br&gt;
height:100%;&lt;br&gt;
transform: rotateX(45deg);
&lt;/div&gt;
&lt;/div&gt;


&lt;div class=&quot;transform-con&quot;&gt;
&lt;div id=&quot;rotate-32&quot; class=&quot;inner&quot;&gt;
width:100%;&lt;br&gt;
height:100%;&lt;br&gt;
transform: rotateY(45deg);
&lt;/div&gt;
&lt;/div&gt;


&lt;div class=&quot;transform-con&quot;&gt;
&lt;div id=&quot;rotate-33&quot; class=&quot;inner&quot;&gt;
width:100%;&lt;br&gt;
height:100%;&lt;br&gt;
transform: rotateZ(45deg);
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;任何有3D变换的元素，不论最后只是做了2D的变换，或者什么都没做&lt;code&gt;translate3d(0,0,0)&lt;/code&gt;，都会触发浏览器去计算。不过，以后会更新优化也不一定。&lt;/p&gt;

&lt;h3&gt;Perspective&lt;/h3&gt;

&lt;p&gt;激活元素的3D空间，需要&lt;code&gt;perspective&lt;/code&gt;属性，写法有两种：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;transform: perspective( 600px );
/**或者**/
perspective: 600px;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两种不同写法，当应用元素只有一个时候，并没有区别，当有多个元素的时候，我们看看效果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#pers-red .item{
  background: red;
  transform: perspective( 400px ) rotateY(45deg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&quot;pers-con&quot; id=&quot;pers-red&quot;&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;/div&gt;


&lt;pre&gt;&lt;code&gt;#pers-blue {
  perspective: 400px;
}

#pers-blue .item{
  background: blue;
  transform: rotateY( 45deg );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&quot;pers-con&quot; id=&quot;pers-blue&quot;&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;上面这两种写法，都触发了元素的3D行为，函数型的写法&lt;code&gt;transform:perspective(400px)&lt;/code&gt;适用于单个元素，会对每一个元素做3D视图的变换，而&lt;code&gt;perspective:400px&lt;/code&gt;的写法，需写在父元素上，然后以父元素的视角，对多个子元素进行3D变换，多个子元素共享同一个3D空间，可以自己打开console修改感受一下。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;perspective&lt;/code&gt;的参数值，决定了3D效果的强烈程度，可以想象为距离多远去观察元素。值越大，观察距离就越远，同样的旋转值，看起来效果就弱一些；值越小，距离越近，3D效果就更强烈。&lt;/p&gt;

&lt;h4&gt;perspective-orgin&lt;/h4&gt;

&lt;p&gt;通常，对一个元素进行3D变换的时候，变换点都是元素的中心点，如果你想以其他的位置为变换点，那就可以用这个属性来做调整：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;perspective-orgin: 20% 70%;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个是默认值的&lt;code&gt;perspective-orign:50% 50%&lt;/code&gt;：&lt;/p&gt;

&lt;div id=&quot;transform1&quot;&gt;
&lt;div class=&quot;inner&quot;&gt;
&lt;img src=&quot;http://lorempixel.com/150/150/city&quot; alt=&quot;Nature&quot;&gt;
&lt;img src=&quot;http://lorempixel.com/150/150/food&quot; alt=&quot;Nature&quot;&gt;
&lt;img src=&quot;http://lorempixel.com/150/150/people&quot; alt=&quot;Nature&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;这个是&lt;code&gt;perspective-orgin: 0% 50%;&lt;/code&gt;&lt;/p&gt;

&lt;div id=&quot;transform1&quot; sytle=&quot;-webkit-perspective-origin:0% 50%;perspective-origin:0% 50%&quot;&gt;
&lt;div class=&quot;inner&quot;&gt;
&lt;img src=&quot;http://lorempixel.com/150/150/nature&quot; alt=&quot;Nature&quot;&gt;
&lt;img src=&quot;http://lorempixel.com/150/150/animals&quot; alt=&quot;Nature&quot;&gt;
&lt;img src=&quot;http://lorempixel.com/150/150/abstract&quot; alt=&quot;Nature&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;h4&gt;transform-style&lt;/h4&gt;

&lt;p&gt;这个参数用来共享父元素的3D空间，这样说起来有些抽象，下面第一个翻卡片的例子中会讲到。&lt;/p&gt;

&lt;h4&gt;backface-visibility&lt;/h4&gt;

&lt;p&gt;backface-visibility 属性可用于隐藏内容的背面。默认情况下，背面可见，这意味着即使在翻转后，变换的内容仍然可见。但当 backface-visibility 设置为 hidden 时，旋转后内容将隐藏，因为旋转后正面将不再可见。该功能可帮助你模拟多面的对象，例如下例中使用的卡片。通过将 backface-visibility 设置为 hidden，可以确保只有正面可见。&lt;/p&gt;

&lt;h2&gt;CSS3 动画实例&lt;/h2&gt;

&lt;p&gt;下面例子中的代码，为了方便查看都没有写浏览器前缀，也没有加入其他的修饰属性，所以实际应用时，不要忘记哦，当然也可以直接console查看。&lt;/p&gt;

&lt;h3&gt;CSS3 翻纸牌&lt;/h3&gt;

&lt;p&gt;做一个翻纸牌的效果，结构很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;cardflip&quot;&amp;gt;
  &amp;lt;div id=&quot;card1&quot;&amp;gt;
    &amp;lt;div class=&quot;front&quot;&amp;gt;1&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;back&quot;&amp;gt;2&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.cardflip&lt;/code&gt;是整个3D效果的容器，&lt;code&gt;#card1&lt;/code&gt;是翻转效果的元素，&lt;code&gt;.front&lt;/code&gt;和&lt;code&gt;.back&lt;/code&gt;是翻转的两面。添加样式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cardflip {
    width: 200px;
    height: 260px;
    position: relative;
    perspective: 800px;
}

#card1 {
    width: 100%;
    height: 100%;
    position: absolute;
    transform-style: preserve-3d;
    transition: transform 1s;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先给&lt;code&gt;#cardflip&lt;/code&gt;添加&lt;code&gt;perspective&lt;/code&gt;属性，这样才能触发3D变换，之后&lt;code&gt;#card1&lt;/code&gt;就在父元素的3D空间中了，用了&lt;code&gt;absolute&lt;/code&gt;来定位子元素，设置宽高都是&lt;code&gt;100%&lt;/code&gt;，这样就可以让&lt;code&gt;transform-origin&lt;/code&gt;在元素的中心点，这个后面再讨论。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;transform-style&lt;/code&gt;有两个值，一个是默认的&lt;code&gt;flat&lt;/code&gt;一个是&lt;code&gt;preserve-3d&lt;/code&gt;，由于&lt;code&gt;perspective&lt;/code&gt;的3D空间，只能作用于直接的子元素，那么&lt;code&gt;.front&lt;/code&gt;和&lt;code&gt;.back&lt;/code&gt;也需要&lt;code&gt;#cardflip&lt;/code&gt;的3D空间的话，就需要给&lt;code&gt;#card1&lt;/code&gt;添加这个属性，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#card1 div{
    position: absolute;
    width: 100%;
    height: 100%;
    backface-visibility: hidden;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只有&lt;code&gt;#card1 div&lt;/code&gt;元素共享了外层元素的3D空间之后，3D变换的属性才能生效，这时候的&lt;code&gt;backface-visibility&lt;/code&gt;才有效，设置为&lt;code&gt;hidden&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#card1 .front {
    background: red;
}

#card1 .back {
    background: blue;
    transform: rotateY( 180deg );
}

#card1.flipped {
    transform: rotateY( 180deg );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为设置了&lt;code&gt;backface-visibility&lt;/code&gt;，而&lt;code&gt;.back&lt;/code&gt;默认就是以Y轴旋转了180度，空间想象一下，&lt;code&gt;.back&lt;/code&gt;就转到背面去了，所以&lt;code&gt;hidden&lt;/code&gt;属性生效，就看不到&lt;code&gt;.back&lt;/code&gt;了。&lt;/p&gt;

&lt;p&gt;当&lt;code&gt;#card1&lt;/code&gt;添加了&lt;code&gt;.flipped&lt;/code&gt;的样式，&lt;code&gt;#card1&lt;/code&gt;以Y轴旋转了180度，这时候&lt;code&gt;.front&lt;/code&gt;转到了背面，而&lt;code&gt;.back&lt;/code&gt;从背面转到了前面，所以就完成了切换。这一段需要仔细的想一想。好了，看看下面的实例，点击即可翻转：&lt;/p&gt;

&lt;div id=&quot;cardflip&quot;&gt;
&lt;div id=&quot;card1&quot;&gt;
&lt;div class=&quot;front&quot;&gt;1&lt;/div&gt;
&lt;div class=&quot;back&quot;&gt;2&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;我们再给这个翻转加一些偏移的效果，看起来会不那么生硬。这就用到了&lt;code&gt;transform-origin&lt;/code&gt;，这个参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#card1 { transform-origin: left center; }

#card1.flipped {
  transform: translateX( 100% ) rotateY( 180deg );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认的&lt;code&gt;transform-origin&lt;/code&gt;是&lt;code&gt;center center&lt;/code&gt;，我们改成&lt;code&gt;left center&lt;/code&gt;之后，就不再以元素的x方向的中心为轴旋转，而是以元素的左边为Y轴旋转，所以还需要给整个&lt;code&gt;#card1&lt;/code&gt;加一个位移量&lt;code&gt;translate&lt;/code&gt;，值是&lt;code&gt;100%&lt;/code&gt;，就是元素本身的宽度。&lt;/p&gt;

&lt;p&gt;可以在console里面去掉&lt;code&gt;#card1.flipped&lt;/code&gt;的&lt;code&gt;translate&lt;/code&gt;帮助理解。&lt;/p&gt;

&lt;div id=&quot;cardflip1&quot;&gt;
&lt;div id=&quot;card2&quot;&gt;
&lt;div class=&quot;front&quot;&gt;1&lt;/div&gt;
&lt;div class=&quot;back&quot;&gt;2&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;这里有一点需要注意，当元素在z轴上有了位移，或者朝向负角度旋转，会导致元素在页面上无法被鼠标点击到，想像一下3D空间，这个元素已经位于整个页面平面的&lt;strong&gt;里面&lt;/strong&gt;，所以无法触及了。&lt;/p&gt;

&lt;h3&gt;CSS3 立方体&lt;/h3&gt;

&lt;p&gt;做完了反转卡片的效果，肯定还想做更炫的，来试试做一个立方体吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;section id=&quot;cube-con&quot;&amp;gt;
  &amp;lt;div id=&quot;cube&quot;&amp;gt;
    &amp;lt;figure class=&quot;front&quot;&amp;gt;1&amp;lt;/figure&amp;gt;
    &amp;lt;figure class=&quot;back&quot;&amp;gt;2&amp;lt;/figure&amp;gt;
    &amp;lt;figure class=&quot;right&quot;&amp;gt;3&amp;lt;/figure&amp;gt;
    &amp;lt;figure class=&quot;left&quot;&amp;gt;4&amp;lt;/figure&amp;gt;
    &amp;lt;figure class=&quot;top&quot;&amp;gt;5&amp;lt;/figure&amp;gt;
    &amp;lt;figure class=&quot;bottom&quot;&amp;gt;6&amp;lt;/figure&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/section&amp;gt;

#cube-con {
    width: 200px;
    height: 200px;
    position: relative;
    perspective: 1000px;
}

#cube {
    width: 100%;
    height: 100%;
    position: absolute;
    transform-style: preserve-3d;
}

#cube figure {
    width: 196px;
    height: 196px;
    display: block;
    position: absolute;
    border: 2px solid black;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一部分和上一个例子没有太大的差别，应该都能理解每一个属性的含义了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cube .front  { transform: rotateY(   0deg ) translateZ( 100px ); }
#cube .back   { transform: rotateX( 180deg ) translateZ( 100px ); }
#cube .right  { transform: rotateY(  90deg ) translateZ( 100px ); }
#cube .left   { transform: rotateY( -90deg ) translateZ( 100px ); }
#cube .top    { transform: rotateX(  90deg ) translateZ( 100px ); }
#cube .bottom { transform: rotateX( -90deg ) translateZ( 100px ); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;立方体的每一个面，经过&lt;code&gt;rotate&lt;/code&gt;旋转之后，就放置在了他该被放置的地方，但是这时候会发现，这些层叠加在一起，还没有成为一个立方体，这时候需要给Z轴一个位移，想象一下我们的视角点在&lt;code&gt;#cube&lt;/code&gt;正中间，拉伸z轴之后，&lt;code&gt;.right&lt;/code&gt;、&lt;code&gt;left&lt;/code&gt;等面就会有一定的角度，参考画画时候的透视，因为刚好在中心点，所以位移量就是宽度的一半。分步过程可以看&lt;a href=&quot;http://desandro.github.io/3dtransforms/examples/cube-01-steps.html&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;因为z轴拉伸之后，原来的对象会被放大一些，这样就会模糊掉，为了去掉这个影响，我们需要把立方体再推回原来的视角平面，于是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cube { transform: translateZ( -100px ); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成了立方体，想让某个面旋转到前方，只需转动整个立方体，不用去调整每个面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cube.show-front  { transform: translateZ( -100px ) rotateY(    0deg ); }
#cube.show-back   { transform: translateZ( -100px ) rotateX( -180deg ); }
#cube.show-right  { transform: translateZ( -100px ) rotateY(  -90deg ); }
#cube.show-left   { transform: translateZ( -100px ) rotateY(   90deg ); }
#cube.show-top    { transform: translateZ( -100px ) rotateX(  -90deg ); }
#cube.show-bottom { transform: translateZ( -100px ) rotateX(   90deg ); }

/**还有过渡效果**/
#cube { transition: transform 1s; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;section id=&quot;cube-con&quot;&gt;&lt;/p&gt;

&lt;div id=&quot;cube&quot;&gt;
&lt;figure class=&quot;front&quot;&gt;1&lt;/figure&gt;
&lt;figure class=&quot;back&quot;&gt;2&lt;/figure&gt;
&lt;figure class=&quot;right&quot;&gt;3&lt;/figure&gt;
&lt;figure class=&quot;left&quot;&gt;4&lt;/figure&gt;
&lt;figure class=&quot;top&quot;&gt;5&lt;/figure&gt;
&lt;figure class=&quot;bottom&quot;&gt;6&lt;/figure&gt;
&lt;/div&gt;


&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;div id=&quot;cube-btn&quot;&gt;
&lt;button data-class=&quot;show-front&quot;&gt;Show Front&lt;/button&gt;
&lt;button data-class=&quot;show-back&quot;&gt;Show Back&lt;/button&gt;
&lt;button data-class=&quot;show-right&quot;&gt;Show Right&lt;/button&gt;
&lt;button data-class=&quot;show-left&quot;&gt;Show Left&lt;/button&gt;
&lt;button data-class=&quot;show-top&quot;&gt;Show Top&lt;/button&gt;
&lt;button data-class=&quot;show-bottom&quot;&gt;Show Bottom&lt;/button&gt;
&lt;/div&gt;


&lt;h3&gt;3D 旋转跑马灯&lt;/h3&gt;

&lt;p&gt;做幻灯片展示的方法有很多，我们用CSS3的3D技术来试试看：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;section class=&quot;container&quot;&amp;gt;
  &amp;lt;div id=&quot;carousel&quot;&amp;gt;
    &amp;lt;figure&amp;gt;1&amp;lt;/figure&amp;gt;
    &amp;lt;figure&amp;gt;2&amp;lt;/figure&amp;gt;
    &amp;lt;figure&amp;gt;3&amp;lt;/figure&amp;gt;
    &amp;lt;figure&amp;gt;4&amp;lt;/figure&amp;gt;
    &amp;lt;figure&amp;gt;5&amp;lt;/figure&amp;gt;
    &amp;lt;figure&amp;gt;6&amp;lt;/figure&amp;gt;
    &amp;lt;figure&amp;gt;7&amp;lt;/figure&amp;gt;
    &amp;lt;figure&amp;gt;8&amp;lt;/figure&amp;gt;
    &amp;lt;figure&amp;gt;9&amp;lt;/figure&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/section&amp;gt;

.container {
  width: 210px;
  height: 140px;
  position: relative;
  perspective: 1000px;
}

#carousel {
  width: 100%;
  height: 100%;
  position: absolute;
  transform-style: preserve-3d;
}

#carousel figure {
  display: block;
  position: absolute;
  width: 186px;
  height: 116px;
  left: 10px;
  top: 10px;
  border: 2px solid black;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这一段，没什么特别要说明的，基本的结构样式，以及之前重点说明过的&lt;code&gt;perspective&lt;/code&gt;和&lt;code&gt;preserve-3d&lt;/code&gt;。现在有9个卡片，要环绕成一圈，那么每个的角度就是&lt;code&gt;40deg&lt;/code&gt; （360/90）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#carousel figure:nth-child(1) { transform: rotateY(   0deg ); }
#carousel figure:nth-child(2) { transform: rotateY(  40deg ); }
#carousel figure:nth-child(3) { transform: rotateY(  80deg ); }
#carousel figure:nth-child(4) { transform: rotateY( 120deg ); }
#carousel figure:nth-child(5) { transform: rotateY( 160deg ); }
#carousel figure:nth-child(6) { transform: rotateY( 200deg ); }
#carousel figure:nth-child(7) { transform: rotateY( 240deg ); }
#carousel figure:nth-child(8) { transform: rotateY( 280deg ); }
#carousel figure:nth-child(9) { transform: rotateY( 320deg ); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，和立方体的例子到同样的步骤了，现在所有的卡片做了Y轴旋转，但因为观察的视角点没有变，所以看起来还是平面，如下这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/8b8af2c8jw1e84s4cel0uj208e05raa0.jpg&quot; alt=&quot;caro&quot; /&gt;&lt;/p&gt;

&lt;p&gt;立方体的位移很好计算，只要是宽度、高度、或者深度的一半就可以了，这个旋转的跑马灯应该怎么计算呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/8b8af2c8jw1e84s5efyxej20f00b6aaj.jpg&quot; alt=&quot;caro-cmpu&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从旋转跑马灯的上方观察，每个卡片的宽度是&lt;code&gt;210px&lt;/code&gt;，角度是&lt;code&gt;40deg&lt;/code&gt;，要计算到中心点的距离，根据旁边的三角形可得：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r = 105 / tan(20deg) = 288px
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#carousel figure:nth-child(1) {transform:rotateY(  0deg) translateZ(288px);}
#carousel figure:nth-child(2) {transform:rotateY( 40deg) translateZ(288px);}
#carousel figure:nth-child(3) {transform:rotateY( 80deg) translateZ(288px);}
#carousel figure:nth-child(4) {transform:rotateY(120deg) translateZ(288px);}
#carousel figure:nth-child(5) {transform:rotateY(160deg) translateZ(288px);}
#carousel figure:nth-child(6) {transform:rotateY(200deg) translateZ(288px);}
#carousel figure:nth-child(7) {transform:rotateY(240deg) translateZ(288px);}
#carousel figure:nth-child(8) {transform:rotateY(280deg) translateZ(288px);}
#carousel figure:nth-child(9) {transform:rotateY(320deg) translateZ(288px);}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;知道了计算方法，如果要改变卡片的个数，或者宽度，只要按照那个公式再计算就好：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var tz = Math.round( ( panelSize / 2 ) / 
  Math.tan( ( ( Math.PI * 2 ) / numberOfPanels ) / 2 ) );
// or simplified to
var tz = Math.round( ( panelSize / 2 ) / 
  Math.tan( Math.PI / numberOfPanels ) );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;计算好卡片的位置之后，然后旋转&lt;code&gt;#carousel&lt;/code&gt;就可以了，当然这个要用js来控制了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#carousel{
    transform: translateZ( -288px ) rotateY( -160deg );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;js代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(function(){
    $(&#39;#car-pre&#39;).click(function(){
        var deg = $(&#39;#carousel&#39;).attr(&#39;data-deg&#39;) || 0;
        deg = parseInt(deg)+40;

        var value = &#39;translateZ(-288px) rotateY(&#39;+deg+&#39;deg)&#39;;

        $(&#39;#carousel&#39;)
            .attr(&#39;data-deg&#39;,deg)
            .css({
                &#39;-webkit-transform&#39;:value
                ,&#39;-moz-transform&#39;:value
                ,&#39;-o-transform&#39;:value
                ,&#39;transform&#39;:value
            });
    });
    $(&#39;#car-next&#39;).click(function(){
        var deg = $(&#39;#carousel&#39;).attr(&#39;data-deg&#39;) || 0;
        deg = parseInt(deg)-40;

        var value = &#39;translateZ(-288px) rotateY(&#39;+deg+&#39;deg)&#39;;

        $(&#39;#carousel&#39;)
            .attr(&#39;data-deg&#39;,deg)
            .css({
                &#39;-webkit-transform&#39;:value
                ,&#39;-moz-transform&#39;:value
                ,&#39;-o-transform&#39;:value
                ,&#39;transform&#39;:value
            });
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;section id=&quot;caro-con&quot;&gt;&lt;div id=&quot;carousel&quot;&gt;&lt;figure&gt;1&lt;/figure&gt;&lt;figure&gt;2&lt;/figure&gt;&lt;figure&gt;3&lt;/figure&gt;&lt;figure&gt;4&lt;/figure&gt;&lt;figure&gt;5&lt;/figure&gt;&lt;figure&gt;6&lt;/figure&gt;&lt;figure&gt;7&lt;/figure&gt;&lt;figure&gt;8&lt;/figure&gt;&lt;figure&gt;9&lt;/figure&gt;&lt;/div&gt;&lt;/section&gt;&lt;/p&gt;

&lt;div id=&quot;car-btn&quot;&gt;
&lt;button id=&quot;car-pre&quot;&gt;&amp;lt; Prev&lt;/button&gt;
&lt;button id=&quot;car-next&quot;&gt;Next &amp;gt;&lt;/button&gt;
&lt;/div&gt;


&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;终于完成了这篇，梳理的过程对我自己很有提高，希望对你也能有些帮助，有兴趣可以关注我，期待下以后的博客~&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Grunt.js 在前端项目中的实战</title>
     <link href="http://beiyuu.com/grunt-in-action"/>
     <updated>2013-07-17T00:00:00+08:00</updated>
     <id>http://beiyuu.com/grunt-in-action</id>
     <content type="html">&lt;h2&gt;Grunt是什么？&lt;/h2&gt;

&lt;p&gt;Grunt已经out了，请用&lt;a href=&quot;http://gulpjs.com/&quot;&gt;Gulp&lt;/a&gt;，参考这篇：&lt;a href=&quot;http://www.smashingmagazine.com/2014/06/11/building-with-gulp/&quot;&gt;Building with Gulp&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;&lt;a href=&quot;http://gruntjs.com/&quot;&gt;Grunt&lt;/a&gt;是一个基于JavaScript的任务运行工具。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;为什么要使用Grunt，简而言之是为了“自动”，用工具自动完成压缩、编译、单元测试、拼写检查等重复性工作。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;Grunt的社区壮大非常快，现在支持的模块有：&lt;a href=&quot;http://coffeescript.org/&quot;&gt;CoffeeScript&lt;/a&gt;、 &lt;a href=&quot;http://handlebarsjs.com/&quot;&gt;handlerbars&lt;/a&gt;、 &lt;a href=&quot;http://jade-lang.com/&quot;&gt;jade&lt;/a&gt;、 &lt;a href=&quot;http://www.jshint.com/&quot;&gt;JSHint&lt;/a&gt;、 &lt;a href=&quot;http://lesscss.org/&quot;&gt;Less&lt;/a&gt;、 &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt;、 &lt;a href=&quot;http://sass-lang.com/&quot;&gt;Sass&lt;/a&gt;、 &lt;a href=&quot;http://learnboost.github.io/stylus/&quot;&gt;stylus&lt;/a&gt;等。&lt;/del&gt;&lt;/p&gt;

&lt;h2&gt;Grunt基本配置&lt;/h2&gt;

&lt;p&gt;Grunt及其插件都是用&lt;a href=&quot;https://npmjs.org/&quot;&gt;npm&lt;/a&gt;管理的，npm是&lt;a href=&quot;http://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;的包管理程序，所以在使用Grunt之前，你需要先安装NodeJS。&lt;/p&gt;

&lt;h3&gt;安装CLI&lt;/h3&gt;

&lt;p&gt;首先需要在全局环境中安装Grunt command line interface (CLI)，在Mac等系统中需要sudo来执行下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g grunt-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这会将&lt;code&gt;grunt&lt;/code&gt;命令安装在系统path中，这样就可以从任何目录执行了。需要注意的是，安装了&lt;code&gt;grunt-cli&lt;/code&gt;并没有安装任务管理工具。&lt;code&gt;CLI&lt;/code&gt;的职责很简单，就是运行&lt;code&gt;Gruntfile&lt;/code&gt;中定义的&lt;code&gt;Grunt&lt;/code&gt;版本，这样你就可以在一台机器运行多个版本的Grunt。&lt;/p&gt;

&lt;p&gt;如果从0.3版本升级，需要先卸载旧版：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm uninstall -g grunt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;已存在Grunt的项目&lt;/h2&gt;

&lt;p&gt;对于已经使用了Grunt的项目，搭建本地环境是非常方便的，只需要切换到该项目目录，然后执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再使用&lt;code&gt;grunt&lt;/code&gt;命令运行Grunt即可。&lt;/p&gt;

&lt;h2&gt;新建Grunt项目&lt;/h2&gt;

&lt;p&gt;最基本的步骤就是给项目添加两个文件&lt;code&gt;package.json&lt;/code&gt;和&lt;code&gt;Gruntfile&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;package.json&lt;/code&gt;：在这个文件里你可以列出项目所需的Grunt插件，npm会自动下载。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Grunfile&lt;/code&gt;：这个文件命名为&lt;code&gt;Gruntfile.js&lt;/code&gt;或者&lt;code&gt;Gruntfile.coffee&lt;/code&gt;，用来描述你所需要的grunt任务。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;package.json&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;package.json&lt;/code&gt;文件需要放置在项目的根目录，和代码一起提交。运行&lt;code&gt;npm install&lt;/code&gt;命令，会安装&lt;code&gt;package.json&lt;/code&gt;中列出的依赖插件的正确版本。&lt;/p&gt;

&lt;p&gt;创建&lt;code&gt;package.json&lt;/code&gt;有以下几种办法：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;大部分&lt;code&gt;grunt-init&lt;/code&gt;模板，会创建项目相关的&lt;code&gt;package.json&lt;/code&gt;文件&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;npm init&lt;/code&gt;命令会创建基本的&lt;code&gt;package.json&lt;/code&gt;文件&lt;/li&gt;
    &lt;li&gt;也可以下面这个范本创建，更多用法可以看&lt;a href=&quot;https://npmjs.org/doc/json.html&quot; target=&quot;_blank&quot; class=&quot;external&quot;&gt;specification&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;{
    &quot;name&quot;: &quot;my-project-name&quot;,
    &quot;version&quot;: &quot;0.1.0&quot;,
    &quot;devDependencies&quot;: {
        &quot;grunt&quot;: &quot;~0.4.1&quot;,
        &quot;grunt-contrib-jshint&quot;: &quot;~0.6.0&quot;,
        &quot;grunt-contrib-nodeunit&quot;: &quot;~0.2.0&quot;,
        &quot;grunt-contrib-uglify&quot;: &quot;~0.2.2&quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;安装Grunt和插件&lt;/h3&gt;

&lt;p&gt;对于已存在&lt;code&gt;package.json&lt;/code&gt;文件的项目，最简单的安装方法就是&lt;code&gt;npm install &amp;lt;module&amp;gt; --save-dev&lt;/code&gt;，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install grunt --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令会安装最新版的&lt;code&gt;grunt&lt;/code&gt;，并且把对这个插件的依赖写入&lt;code&gt;package.json&lt;/code&gt;。很方便。&lt;/p&gt;

&lt;h2&gt;Gruntfile&lt;/h2&gt;

&lt;p&gt;和&lt;code&gt;package.json&lt;/code&gt;文件一样，&lt;code&gt;Gruntfile.js&lt;/code&gt;或者&lt;code&gt;Gruntfile.coffee&lt;/code&gt;需要放在根目录下和源码一起提交。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Gruntfile&lt;/code&gt;由以下几个部分组成：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;wrapper&lt;/code&gt;函数&lt;/li&gt;
    &lt;li&gt;项目和任务配置&lt;/li&gt;
    &lt;li&gt;加载Grunt插件和任务&lt;/li&gt;
    &lt;li&gt;自定义任务&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;示例Gruntfile&lt;/h3&gt;

&lt;p&gt;在下面这个例子中，项目信息引自&lt;code&gt;package.json&lt;/code&gt;，grunt-contrib-uglify插件的&lt;code&gt;uglify&lt;/code&gt;任务用来压缩js文件，并且根据项目的metadata生成一条注释。当grunt运行时，uglify任务会默认执行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = function(grunt) {

  // Project configuration.
  grunt.initConfig({
    pkg: grunt.file.readJSON(&#39;package.json&#39;),
    uglify: {
      options: {
        banner: &#39;/*! &amp;lt;%= pkg.name %&amp;gt; &amp;lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&amp;gt; */\n&#39;
      },
      build: {
        src: &#39;src/&amp;lt;%= pkg.name %&amp;gt;.js&#39;,
        dest: &#39;build/&amp;lt;%= pkg.name %&amp;gt;.min.js&#39;
      }
    }
  });

  // Load the plugin that provides the &quot;uglify&quot; task.
  grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);

  // Default task(s).
  grunt.registerTask(&#39;default&#39;, [&#39;uglify&#39;]);

};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是一个完整的&lt;code&gt;Gruntfile&lt;/code&gt;，我们仔细研究下。&lt;/p&gt;

&lt;h3&gt;wrapper函数&lt;/h3&gt;

&lt;p&gt;每个&lt;code&gt;Gruntfile&lt;/code&gt;（包括插件）使用这个默认的格式，你的所有的Grunt代码也必须写在这个函数中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.export = function(grunt){
    //Do grunt-related things in here
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;项目和任务配置&lt;/h3&gt;

&lt;p&gt;大多Grunt的任务依赖于&lt;a href=&quot;http://gruntjs.com/grunt#grunt.initconfig&quot;&gt;grunt.initConfig&lt;/a&gt;方法中定义的配置。&lt;/p&gt;

&lt;p&gt;在这个例子中，Grunt通过&lt;code&gt;grunt.file.readJSON(&#39;package.json&#39;)&lt;/code&gt;引入了&lt;code&gt;package.json&lt;/code&gt;中定义的Grunt配置。因为&lt;code&gt;&amp;lt;% %&amp;gt;&lt;/code&gt;模板变量可以引用任何配置，所以像文件路径、文件列表这些内容应该存储在变量中，以减少重复。&lt;/p&gt;

&lt;p&gt;和其他任务一样，任务的配置需要和任务名字一样的变量，具体的参数可以查询各任务的文档。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Project configuration.
grunt.initConfig({
  pkg: grunt.file.readJSON(&#39;package.json&#39;),
  uglify: {
    options: {
      banner: &#39;/*! &amp;lt;%= pkg.name %&amp;gt; &amp;lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&amp;gt; */\n&#39;
    },
    build: {
      src: &#39;src/&amp;lt;%= pkg.name %&amp;gt;.js&#39;,
      dest: &#39;build/&amp;lt;%= pkg.name %&amp;gt;.min.js&#39;
    }
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;加载Grunt的插件和任务&lt;/h3&gt;

&lt;p&gt;很多常用的任务比如&lt;a href=&quot;https://github.com/gruntjs/grunt-contrib-concat&quot;&gt;concatenation&lt;/a&gt;、 &lt;a href=&quot;http://github.com/gruntjs/grunt-contrib-uglify&quot;&gt;minification&lt;/a&gt;、 &lt;a href=&quot;https://github.com/gruntjs/grunt-contrib-jshint&quot;&gt;linting&lt;/a&gt;都有&lt;a href=&quot;https://github.com/gruntjs&quot;&gt;Grung插件&lt;/a&gt;。只要在&lt;code&gt;package.json&lt;/code&gt;中声明，然后通过&lt;code&gt;npm install&lt;/code&gt;安装，就可以在&lt;code&gt;Gruntfile&lt;/code&gt;中配置使用了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Load the plugin that provides the &quot;uglify&quot; task.
grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;grunt --help&lt;/code&gt;可以查看所有可用的任务。&lt;/p&gt;

&lt;h3&gt;自定义任务&lt;/h3&gt;

&lt;p&gt;你可以配置让Grunt运行一个或多个默认任务。在例子中，运行&lt;code&gt;grunt&lt;/code&gt;不带任何参数就会执行&lt;code&gt;uglify&lt;/code&gt;任务。这和&lt;code&gt;grunt uglify&lt;/code&gt;或者&lt;code&gt;grunt default&lt;/code&gt;是一样的效果。数组的长度任意。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Default task(s).
grunt.registerTask(&#39;default&#39;, [&#39;uglify&#39;]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你需要的任务并没有插件提供，那么也可以自定义，自定义的任务可以不写任务配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = function(grunt) {

  // A very basic default task.
  grunt.registerTask(&#39;default&#39;, &#39;Log some stuff.&#39;, function() {
    grunt.log.write(&#39;Logging some stuff...&#39;).ok();
  });

};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自定义的任务也不必一定写在&lt;code&gt;Gruntfile&lt;/code&gt;中，也可以定义在外部的&lt;code&gt;.js&lt;/code&gt;文件中，然后通过&lt;a href=&quot;http://gruntjs.com/grunt#grunt.loadtasks&quot;&gt;grunt.loadTasks&lt;/a&gt;来加载。&lt;/p&gt;

&lt;h2&gt;实战&lt;/h2&gt;

&lt;p&gt;grunt插件中有contrib前缀的是Grunt团队自行开发的插件，也是推荐使用的，下面挑选几个在前端项目中必用的插件，在实际例子中介绍一下使用方法。&lt;/p&gt;

&lt;h3&gt;grunt-contrib-compass&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://compass-style.org/&quot;&gt;Compass&lt;/a&gt;是&lt;a href=&quot;http://sass-lang.com/&quot;&gt;SASS&lt;/a&gt;的一个框架，就像jQuery之于Javascript、Rails之于Ruby。具体的用法可以参考阮一峰的这两篇Blog:&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/06/sass.html&quot;&gt;SASS用法指南&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/11/compass.html&quot;&gt;Compass用法指南&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;首先，安装&lt;a href=&quot;https://npmjs.org/package/grunt-contrib-compass&quot;&gt;grunt-contrib-compass&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install grunt-contrib-compass --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如前所述，&lt;code&gt;--save-dev&lt;/code&gt;可以在安装插件的过程中，将对这个插件的依赖自动写入&lt;code&gt;package.json&lt;/code&gt;文件中，方便。&lt;/p&gt;

&lt;p&gt;Compass并没有暴露所有的设置给Grunt，如果有别的需要，可以在config里面指定&lt;code&gt;config.rb&lt;/code&gt;给Compass编译使用。看一个配置的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = function(grunt){
    grunt.initConfig({
      compass: {                  // compass任务
        dist: {                   // 一个子任务
          options: {              // 任务的设置
            sassDir: &#39;sass&#39;,
            cssDir: &#39;css&#39;,
            environment: &#39;production&#39;
          }
        },
        dev: {                    // 另一个子任务
          options: {
            sassDir: &#39;sass&#39;,
            cssDir: &#39;style&#39;
          }
        }
      }
    });

    grunt.loadNpmTasks(&#39;grunt-contrib-compass&#39;);

    grunt.registerTask(&#39;default&#39;, [&#39;compass&#39;]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要使用外部文件的配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt.initConfig({
  compass: {
    dist: {
      options: {
        config: &#39;config/config.rb&#39;
      }
    }
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;grunt-contrib-concat&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://npmjs.org/package/grunt-contrib-concat&quot;&gt;grunt-contrib-concat&lt;/a&gt;是一个合并文件的插件，可以将多个css或js文件合并为一个，以节省链接数。同样的，安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install grunt-contrib-concat --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个插件有一下几个常用配置：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;seperator&lt;/code&gt;：被合并的文件会用这个参数来join，例如你在合并压缩后的js文件时，可以加个&lt;code&gt;;&lt;/code&gt;防止出错&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;banner&lt;/code&gt;：在合并后的文件头部加一些额外信息&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;footer&lt;/code&gt;：在合并后的文件尾部加一些额外信息&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;再看一下用法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt.initConfig({
  pkg: grunt.file.readJSON(&#39;package.json&#39;),
  concat: {
    options: {                                                      //配置
      stripBanners: true,
      banner: &#39;/*! &amp;lt;%= pkg.name %&amp;gt; - v&amp;lt;%= pkg.version %&amp;gt; - &#39; +      //添加自定义的banner
        &#39;&amp;lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&amp;gt; */&#39;
    },
    dist: {                                                         //任务
        src: [&#39;src/intro.js&#39;, &#39;src/project.js&#39;, &#39;src/outro.js&#39;],    //源目录文件
        dest: &#39;dist/built.js&#39;                                       //合并后的文件
    },
    basic_and_extras: {                                             //另一个任务
        files: {                                                    //另一种更简便的写法
            &#39;dist/basic.js&#39;: [&#39;src/main.js&#39;],
            &#39;dist/with_extras.js&#39;: [&#39;src/main.js&#39;, &#39;src/extras.js&#39;]
        }
    }
  }
});

grunt.loadNpmTasks(&#39;grunt-contrib-concat&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后在&lt;code&gt;default&lt;/code&gt;事件中添加&lt;code&gt;concat&lt;/code&gt;就会默认执行了。&lt;/p&gt;

&lt;h3&gt;grunt-contrib-uglify&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://npmjs.org/package/grunt-contrib-uglify&quot;&gt;grunt-contrib-uglify&lt;/a&gt;用来压缩js文件，用法与&lt;code&gt;concat&lt;/code&gt;类似，先安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install grunt-contrib-uglify --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后写入相应的配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt.initConfig({
  uglify: {
    options: {
      banner: &#39;/*! This is uglify test - &#39; +
        &#39;&amp;lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&amp;gt; */&#39;
    },
    app_task: {
      files: {
        &#39;dist/app.min.js&#39;: [&#39;js/app.js&#39;, &#39;js/render.js&#39;]
      }
    }
  }
});

grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;恩，经过如此处理，你的js代码已经丑陋到无法直视了。&lt;/p&gt;

&lt;h3&gt;grunt-contrib-watch&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://npmjs.org/package/grunt-contrib-watch&quot;&gt;grunt-contrib-watch&lt;/a&gt;是开发必备插件，用来监控文件的修改，然后自动运行grunt任务，省去一遍遍手动执行Grunt命令，安装照旧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install grunt-contrib-watch --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用watch插件时，需要注意一点，被watch的文件，可以分开写，这样可以提高watch的性能，不用每次把没修改的文件也执行一遍任务，看看例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt.initConfig({
  watch: {
    css: {
      files: [&#39;public/scss/*.scss&#39;],
      tasks: [&#39;compass&#39;],
      options: {
        // Start a live reload server on the default port 35729
        livereload: true,
      },
    },
    another: {
      files: [&#39;lib/*.js&#39;],
      tasks: [&#39;anothertask&#39;],
      options: {
        // Start another live reload server on port 1337
        livereload: 1337,
      },
    }
  }
});

grunt.loadNpmTasks(&#39;grunt-contrib-watch&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后运行&lt;code&gt;grunt watch&lt;/code&gt;命令，修改文件，就会看到设定的任务执行了。&lt;/p&gt;

&lt;h2&gt;源码&lt;/h2&gt;

&lt;p&gt;Grunt的基本使用就是这些了，当然还有一些&lt;a href=&quot;http://gruntjs.com/project-scaffolding&quot;&gt;搭建脚手架&lt;/a&gt;等等的功能，等待你自己去学习使用吧，更多的&lt;a href=&quot;http://gruntjs.com/plugins/&quot;&gt;Grunt 插件&lt;/a&gt;也等待你去发现。&lt;/p&gt;

&lt;p&gt;贴出来源码，整体看一下：&lt;/p&gt;

&lt;h3&gt;package.json&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;{
  &quot;name&quot;: &quot;Grunt-in-action&quot;,
  &quot;devDependencies&quot;: {
    &quot;grunt&quot;: &quot;~0.4.1&quot;,
    &quot;grunt-contrib-compass&quot;: &quot;~0.3.0&quot;,
    &quot;grunt-contrib-watch&quot;: &quot;~0.4.4&quot;,
    &quot;grunt-contrib-concat&quot;: &quot;~0.3.0&quot;,
    &quot;grunt-contrib-uglify&quot;: &quot;~0.2.2&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Gruntfile.js&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;module.exports = function(grunt){
    grunt.initConfig({
        compass: {                  // Task
            dist: {                   // Target
                options: {              // Target options
                    sassDir: &#39;sass&#39;,
                    cssDir: &#39;css&#39;,
                    environment: &#39;production&#39;
                }
            },
            dev: {                    // Another target
                options: {
                    sassDir: &#39;sass&#39;,
                    cssDir: &#39;style&#39;
                }
            }
        },

        concat: {
            options: {                                       //配置
                stripBanners:true,
                banner: &#39;/*! This is the grunt test &#39; +      //添加自定义的banner
                &#39;&amp;lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&amp;gt; */&#39;
            },
            basic: {                                         //另一个任务
                files: {                                     //另一种更简便的写法
                    &#39;dist/style.css&#39;: [&#39;style/screen.css&#39;,&#39;style/ie.css&#39;,&#39;style/print.css&#39;]
                }
            }
        },

        uglify: {
            options: {
                banner: &#39;/*! This is uglify test - &#39; +
                &#39;&amp;lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&amp;gt; */&#39;
            },
            app_task: {
                files: {
                    &#39;dist/app.min.js&#39;: [&#39;js/app.js&#39;, &#39;js/render.js&#39;]
                }
            }
        },

        watch: {
            css: {
                files: [&#39;sass/*.scss&#39;],
                tasks: [&#39;compass&#39;, &#39;concat&#39;]
            },
            another: {
                files: [&#39;js/*.js&#39;],
                tasks: [&#39;uglify&#39;]
            }
        }
    });

    grunt.loadNpmTasks(&#39;grunt-contrib-compass&#39;);
    grunt.loadNpmTasks(&#39;grunt-contrib-concat&#39;);
    grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);
    grunt.loadNpmTasks(&#39;grunt-contrib-watch&#39;);

    grunt.registerTask(&#39;default&#39;, [&#39;compass&#39;,&#39;concat&#39;, &#39;uglify&#39;]);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>豆瓣FM(iOS 3.0)使用体会</title>
     <link href="http://beiyuu.com/douban-fm"/>
     <updated>2013-06-06T00:00:00+08:00</updated>
     <id>http://beiyuu.com/douban-fm</id>
     <content type="html">&lt;p&gt;豆瓣FM发布了全新设计的3.0版本，很多Feature不错：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;全新设计，清新、大气&lt;/li&gt;
    &lt;li&gt;操作流畅爽滑，运行交互效率很高&lt;/li&gt;
    &lt;li&gt;终于有歌词啦&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;使用中总结了一些体会，非常感性、毫无逻辑可言，看看就好：&lt;/p&gt;

&lt;h2&gt;产品定位&lt;/h2&gt;

&lt;p&gt;豆瓣FM的产品定位，摘抄如下：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;它简单、易用，熟悉每个用户的脾气秉性，又能够聚合集体的智慧。无论是在家里、工作场所、咖啡厅还是交通工具上，无论是在休息、等候、娱乐还是工作时，它都能够提供完美、一致的体验。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;大家对推荐都满意，算法就不说了。简单易用来讲，国内的音乐APP中(虾米、QQ、百度等)，只有豆瓣是打开就播放，确实简单易用。&lt;/p&gt;

&lt;p&gt;这样的打开播放的产品定位下，使用场景就有些变化了。&lt;/p&gt;

&lt;h2&gt;交互框架&lt;/h2&gt;

&lt;h3&gt;引导页&lt;/h3&gt;

&lt;p&gt;从App引导开始，新版FM就想让用户熟悉上下拉动的操作。&lt;/p&gt;

&lt;p&gt;豆瓣这次竟然使用了被吐槽无数次的App引导，还蛮让人意外的。是对交互设计不自信吗？观察周围使用的人以及我自己，基本上没人会去看引导页的内容，况且下拉的操作违反直觉，更容易招惹反感，播放页面也被蒙层，我直观感受是恐惧。&lt;/p&gt;

&lt;p&gt;登录和进入按钮被放置在引导页下方，并且位置尴尬，大约是为了让用户感受到下面还有内容，平衡了讨厌引导的用户需求(估计设计师自己也讨厌引导吧)，却牺牲了美感。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw1024/8b8af2c8jw1e5eqcvmp9gj20oq0lp408.jpg&quot; alt=&quot;splash&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;上下拉&lt;/h3&gt;

&lt;p&gt;自从抽屉式导航普及开来之后，横滑展开设置成为一种默认操作。&lt;/p&gt;

&lt;p&gt;上下拉在虾米音乐中也有被应用，但和豆瓣的不同在于：虾米入口界面不是播放页，而是搜索、我的虾米、本地音乐这样的交互界面，此时播放页从下拉上来，更像是另一个维度的事情，并且主界面的交互有很多，播放页到另一个维度是很好理解的事情。硬套生活中所讲的横向、纵向的概念也完全讲的通。&lt;/p&gt;

&lt;p&gt;豆瓣FM的逻辑不完美在于，他的主页是播放页，选择兆赫更像是个设置，硬说他是另一个维度也没错，但是这两个的关系太平等（都只有一个），上下拉就显得违反直觉了。&lt;/p&gt;

&lt;p&gt;而且没人看引导，反直觉的上下拉动的交互，让很多人不知所措，顶部也没有标记表明那是可以拉动的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw1024/8b8af2c8jw1e5eqd2xcj9j20oq0lpjv1.jpg&quot; alt=&quot;slide&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;设计细节&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;封面不清晰&lt;/li&gt;
&lt;li&gt;对话框关闭按钮在左边，为什么呢？&lt;/li&gt;
&lt;li&gt;兆赫不能搜索，连换一批也不能？更新说明说动态切换，怎么切换？&lt;/li&gt;
&lt;li&gt;暂停、播放按钮太小（上面显示广告也罢了，下面那么大的空间，完全可以利用起来）&lt;/li&gt;
&lt;li&gt;只支持上下拉的手势，却不支持左右后退的手势？（更新说明里我瞟见了手势两个字）&lt;/li&gt;
&lt;li&gt;顶部“正在同步”等状态栏，完全遮挡操作按钮，为什么不加后退手势这种标配呢？&lt;/li&gt;
&lt;li&gt;在上下拉的交互框架中，歌曲状态栏细节做的很到位（比如当上下拉到歌曲名称位置的时候，状态栏才会fix住），但是上拉拖动的时候，状态栏此时是拖动的把手，却自己不动弹，逻辑又奇怪了不是？&lt;/li&gt;
&lt;li&gt;其他的程序BUG，比如红心数目不对等等。&lt;/li&gt;
&lt;li&gt;如何收藏兆赫，研究许久才知道是长按。&lt;/li&gt;
&lt;li&gt;也是琢磨了半天才知道，点头像是进入设置。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw1024/8b8af2c8jw1e5eqd8tkg5j20oq0lpjti.jpg&quot; alt=&quot;slide&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再重复一下，APP引导太可怕了！ 我说的全是废话，因为这个版本发布后，看起来好评如潮，哎。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>史蒂夫·乔布斯：遗失的访谈</title>
     <link href="http://beiyuu.com/jobs-interview"/>
     <updated>2013-05-14T00:00:00+08:00</updated>
     <id>http://beiyuu.com/jobs-interview</id>
     <content type="html">&lt;h2&gt;1、做公司就是做产品&lt;/h2&gt;

&lt;p&gt;乔布斯从12岁开始，就捣鼓着好玩有用的产品，在惠普兼职的那些日子，也让他体会到了科技的魅力，原来凭一个人的力量也可以有如此之大的影响力，也是在惠普他认识了沃兹尼亚克。&lt;/p&gt;

&lt;p&gt;Apple II发布时，乔布斯年仅21岁，从此之后，他的财富不断增加，23岁一百万，24岁一千万，25岁一亿美元。但是钱并不是乔布斯认为最重要的东西，重要的是人才、产品，是产品带给用户的价值。&lt;/p&gt;

&lt;p&gt;做产品要深入的每一个细节，要去控制成本，就必须知道每一个步骤的精确成本，他也建议所有人都去学习一下编程，学习这种思考问题的方式。&lt;/p&gt;

&lt;p&gt;乔布斯举了百事可乐的例子，来说明大公司为什么会失败，因为一旦公司做大，形成垄断市场之后，产品数十年也不会发生多大的变化，而且这些垄断的市场也很难再提高业绩，要提高业绩还得靠营销部门，最终营销人员挤走了产品人员，而营销人员并不懂产品，这情形在百事可乐这样的公司没问题，但在科技公司就会造成悲剧。&lt;/p&gt;

&lt;p&gt;光靠流程和制度，是不能让公司持续成功的，必须全心全意放在产品上。&lt;/p&gt;

&lt;h2&gt;2、如何使公司良好运转&lt;/h2&gt;

&lt;p&gt;对于传统行业来说，最好和普通之间，差距可能就是百分之几十的样子，但是对科技行业来说，最好的与普通的人才，能力的差距可能达百倍，所以一流的公司需要一流的人才，一流的人才也愿意与一流的人才共事。&lt;/p&gt;

&lt;p&gt;团队的协作过程，就像磨石机的工作过程一样，会有摩擦会有障碍，这是必然的，以乔布斯的理解来看，真正优秀的人，只想成功，不在乎是非，用事实说话，其他的都不重要，他认为优秀的人也不太需要你太在乎他们的自尊。&lt;/p&gt;

&lt;p&gt;大约这就是他被谣传暴戾的原因吧，从访谈中可以看的出，他确实不太在乎事实之外的东西，他自己也会犯错，别人也可以说服他，只要基于事实就好。&lt;/p&gt;

&lt;h2&gt;3、品位问题&lt;/h2&gt;

&lt;p&gt;毫无疑问，乔布斯的品位很好，他认为和在大学时旁听排版课程的关系密不可分，的确，内容永远都是最重要的，并且，字体设计那些细致入微的细节，也对他有很深的影响。&lt;/p&gt;

&lt;p&gt;微软是一个成功的公司，善于抓住机遇，但是他们的产品毫无品位，是三流的，或许没有苹果，微软的产品会更糟糕，没有灵魂，非常平庸，但是更令人可悲的是用户并不以为然。&lt;/p&gt;

&lt;p&gt;人类应该追求极致，并分享给同类。&lt;/p&gt;

&lt;p&gt;乔布斯也从来不觉得借鉴别人的创意是可耻的，笨拙的工匠只会抄，灵巧的工匠会借鉴的恰到好处，苹果的产品非常确切的说明了这个事实。&lt;/p&gt;

&lt;p&gt;6、70年代的嬉皮士运动给乔布斯留下了深刻印象，他认为嬉皮士是去努力寻找生活的真相的一群人，他们觉得生活不应该是父母过的那样。嬉皮士的出发点是可贵的。也正是因为这种精神，有人宁愿当诗人也不愿做银行家。&lt;/p&gt;

&lt;p&gt;乔布斯很欣赏这种精神，他也想把这种精神溶入到产品中。只要用户使用产品，就能感受到这种精神，如果与Macintosh的用户交谈，会发现他们喜爱这个产品，在此之前，你很少听人说真心喜欢某个商业产品——是的，但你可以从Macintosh感受到某种奇妙的东西。&lt;/p&gt;

&lt;!--&lt;iframe height=&quot;498&quot; width=&quot;510&quot; src=&quot;http://player.youku.com/embed/XNTUxNDY1NDY4&quot; frameborder=&quot;0&quot; style=&quot;margin:0 auto&quot;&gt;&lt;/iframe&gt;--&gt;




&lt;div style=&quot;text-align:center&quot;&gt;
&lt;embed src=&quot;http://player.youku.com/player.php/sid/XNTUxNDY1NDY4/v.swf&quot; allowFullScreen=&quot;true&quot; quality=&quot;high&quot; width=&quot;480&quot; height=&quot;400&quot; align=&quot;middle&quot; allowScriptAccess=&quot;always&quot; type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/embed&gt;
&lt;/div&gt;

</content>
   </entry>
   
   <entry>
     <title>Tabby</title>
     <link href="http://beiyuu.com/tabby"/>
     <updated>2013-04-12T00:00:00+08:00</updated>
     <id>http://beiyuu.com/tabby</id>
     <content type="html">&lt;p&gt;用&lt;a href=&quot;https://chrome.google.com/webstore/detail/tabby/pifnjkdglcfkfpdjdolfacpfdlgpdkhp&quot; title=&quot;Tabby&quot;&gt;Tabby&lt;/a&gt;有一阵子了，最近把细节完善，发布在了Chrome Store。&lt;/p&gt;

&lt;p&gt;他的功能是，当你打开几十上百个Chrome标签，很占资源，不想加入书签，也不想存入Instapaper等Read It Later的东西，只看一次，但就是不想现在看，这时候只要在页面点击右键，选择“暂存到Tabby”即可。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/tabby/pifnjkdglcfkfpdjdolfacpfdlgpdkhp&quot; title=&quot;Tabby&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/other/Tabby-pro1.png&quot; alt=&quot;Tabby&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;你可以设置使用快捷键（默认关闭），要打开暂存的标签，只需点击Tabby的图标。因为使用了Chrome的书签，即使你卸载插件，还没来得及看的也不会丢失，也会默认同步到别的设备。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/tabby/pifnjkdglcfkfpdjdolfacpfdlgpdkhp&quot; title=&quot;Tabby&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/other/Tabby-pro2.png&quot; alt=&quot;Tabby&quot; &gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;推荐一本书&lt;a href=&quot;http://read.douban.com/ebook/709141/?referral_code=e6acsgl3&quot; title=&quot;我是个年轻人，我心情不太好&quot;&gt;我是个年轻人，我心情不太好&lt;/a&gt;，当时是他的简介让我动心了一下：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;我25岁，读过一个硕士，但是退学了。我被时间、空间、意义这些事情烦扰着。我知道的东西多得难以置信。我知道名字，年份。数以百计。我知道谁第一个上的珠穆朗玛峰。我知道谁导演了那些美国最蹩脚的肥皂剧。我知道亚里士多德讲的话是啥意思。我知道时间在太阳上会走得慢一点……&lt;/p&gt;

&lt;p&gt;但是，我知道这些有什么意义呢？&lt;/p&gt;

&lt;p&gt;我的生活仍旧是一团糟。&lt;/p&gt;

&lt;p&gt;不，连一团糟都不是，它是一片空白。&lt;/p&gt;

&lt;p&gt;我没有女朋友，甚至没有很好很好的朋友。我有一个哥哥，还有一个比我小很多、还在上幼儿园的“伙伴”。可他们也不算是朋友。&lt;/p&gt;

&lt;p&gt;要是我能有一种非常靠谱的感觉，觉得一切都会好起来，那该多好。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;不指望这本书能喂你多大一碗鸡汤，就是让你知道这个年纪的共同态，而且或许有解决办法。&lt;/p&gt;

&lt;p&gt;好吧，去下载插件吧：
&lt;a href=&quot;https://chrome.google.com/webstore/detail/tabby/pifnjkdglcfkfpdjdolfacpfdlgpdkhp&quot; title=&quot;Tabby&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/other/Tabby-440.png&quot; alt=&quot;Tabby&quot; width=&quot;300&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
   </entry>
   
 
</feed>
