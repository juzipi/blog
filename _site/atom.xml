<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>juzipi</title>
   <link href="blog//atom.xml" rel="self" type="application/atom+xml"/>
   <link href="blog/" rel="alternate" type="text/html" />
   <updated>2015-06-25T17:25:45+08:00</updated>
   <id>blog/</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>jekyll基本使用方式</title>
     <link href="http://beiyuu.com/jekyll%E4%BD%BF%E7%94%A8"/>
     <updated>2015-06-25T00:00:00+08:00</updated>
     <id>http://beiyuu.com/jekyll使用</id>
     <content type="html">&lt;h2&gt;基本使用方式&lt;/h2&gt;

&lt;p&gt;安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem install jekyll
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入文件夹&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jekyll new my-site
cd my-site
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jekyll serve

服务地址：http://localhost:4000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建立&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jekyll bulid

jekyll bulid -watch //持续跟踪
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文章要求&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: post
title: jekyll基本使用方式
description: jekyll基本使用方式
category: blog
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
</content>
   </entry>
   
   <entry>
     <title>原型理解</title>
     <link href="http://beiyuu.com/%E5%8E%9F%E5%9E%8B%E7%90%86%E8%A7%A3"/>
     <updated>2014-12-17T00:00:00+08:00</updated>
     <id>http://beiyuu.com/原型理解</id>
     <content type="html">&lt;h1&gt;原型解析&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;什么是原型?&lt;/li&gt;
&lt;li&gt;原型的作用是什么？&lt;/li&gt;
&lt;li&gt;堆和栈的区别？&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;1.对象分类&lt;/h2&gt;

&lt;p&gt;在js中有一个概念就是一切皆是对象，但是对象也有分不同的类型
先抛出几个问题在这篇文章中去解答：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;普通对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; var o = new Object();
 var o1 = {};
 var ff=function(){}; var o2=new ff();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; var f=function(){};
 var f1=Function(&quot;sopit&quot;,&quot;alert(&#39;a&#39;)&quot;);
 function f2(){}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原型对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; //源码

 function myFun(){
     var name=&quot;juzi&quot;;
 }

 function myFunPro(){
     this.name=&quot;juzi&quot;;
     this.t=function(){
         return &quot;tt&quot;;
     }
 }

 myFunPro.prototype.title=function(){
     return &quot;biaoti&quot;;
 }

 var m=new myFun();

 myFun.prototype=m;

 var u=i=m;

 var mP=new myFunPro();

 var o=new Object();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;blockquote&gt;&lt;p&gt;顺便说几个方法&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;tpyeof 可以知道数据类型，number,object,function,undefinded,boolean,string
 判断变量是否存在，使用typeof，例如：&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    if(a){alert(&quot;a&quot;);} //有抱错信息
    if(typeof !=&quot;undefined&quot;){ alert(&quot;a&quot;); } //不会报错
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;instanceof 可以判断是否是实例，例如： a instanceof A；输出的事一个布尔值&lt;/li&gt;
&lt;/ol&gt;


&lt;blockquote&gt;&lt;/blockquote&gt;

&lt;p&gt;我想到这里可以说一下原型有什么作用了：
1. 用来继承减少空间占用&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>学习笔记－设计模式 －函数</title>
     <link href="http://beiyuu.com/Javascript%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0"/>
     <updated>2014-09-20T00:00:00+08:00</updated>
     <id>http://beiyuu.com/Javascript模式学习-函数</id>
     <content type="html">&lt;h2&gt;第四章 函数&lt;/h2&gt;

&lt;h3&gt;4.1 背景&lt;/h3&gt;

&lt;p&gt;函数是js中使用率最高的一个对象，万物皆对象。函数也不例外，只是这个对象和别的对象来说有几个特别的特性，“执行”是其中一个。&lt;/p&gt;

&lt;p&gt;另外两个特性包括：是一个一等对象，提供作用域的支持。&lt;/p&gt;

&lt;p&gt;js本身有两种作用域，一种是全局的作用域，比如window，还有一个就是局部作用域，比如函数内用var声明的作用域，函数内用if或者for等内部声明的作用域还是属于函数内部的作用域，不属于if内部的作用域。&lt;/p&gt;

&lt;p&gt;函数既然也是对象，那么就会一样会有对象的一些特性，比如有 &lt;strong&gt;属性&lt;/strong&gt; 和 &lt;strong&gt;方法&lt;/strong&gt;。&lt;/p&gt;

&lt;h4&gt;函数的中的匿名函数和命名函数之间的区别：&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;匿名函数的name属性值是一个空字符串，命名函数的name值是有值的。这是他们唯一的区别。
真正有三种术语方面的说法：带有命名的函数表达式、无名字的函数表达式、函数声明&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var add = function add(){}; //带有命名的函数表达式,末尾必须要有分号

var add = function (){};  //无名字的函数表达式

function add(){}; //函数声明，末尾可以不用分号
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;“函数直接量”这个概念一般用来表示函数表达式或者匿名函数表达式，尽量不要用，有歧义。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3&gt;4.2 函数提前&lt;/h3&gt;

&lt;p&gt;前面有过叫做变量提前的说法，也就是在运行环境中，变量始终会方便开始，即使是后面定义的也是如此。函数也有提前这一说法，因为函数也是一种对象，赋值给了变量。&lt;/p&gt;

&lt;p&gt;“函数声明”定义的函数不仅能够让函数&lt;strong&gt;定义&lt;/strong&gt;提前，还能够让声明提前。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo(){console.log(&quot;foo&quot;)}
function bar(){console.log(&quot;bar&quot;)}

function next(){

    //next 内部的foo和bar会覆盖全局的foo和bar

    console.log(typeof foo);  //function 因为foo是一个函数声明
    console.log(typeof bar);  //undefined  bar是一个无名的函数表达式

    foo();  // new foo
    bar();  //typeError: bar is not a function 

    function foo(){
        console.log(&quot;new foo&quot;)
    }
    var bar = function(){
        console.log(&quot;new bar&quot;)          
    };
    console.log(typeof bar);  //function 

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;4.3 回调模式&lt;/h3&gt;

&lt;p&gt;该模式应该是函数经常用到的一个方式，因为函数是对象，也就是说函数可以作为参数传递给另外一个函数，当给函数传入一个函数参数，并且在函数内调用了函数参数，并执行，称传入参数的函数叫回调函数，也成回调。
    function f(callback){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    callback();//执行了
}       

function cb(){
    console.log(&quot;回调&quot;);
}   

f(cb);// 回调
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;遍历节点并做一定动作，一般逻辑，把节点抛出来，并用方法隐藏，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//findNodes 方法找到节点并返回出来，
 var findNodes = function(){
    var nodeParent = document.getElementById(&quot;J_ul&quot;);
    var nodes = nodeParent.getElementsByTagName(&quot;li&quot;);
    return nodes;
 }

 //隐藏节点
var hide = function(node){
    var i=0, max = node.length; //遍历节点
    for(; i &amp;lt; max; i++){
     node[i].style.display = &quot;none&quot;;
    }
}

//显示节点
var show = function(node){
    var i=0, max = node.length; //遍历节点
    for(; i &amp;lt; max; i++){
        node[i].style.display = &quot;block&quot;;
    }
}

//执行
hide(findNodes());
show(findNodes());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里做一次操作就会遍历节点一遍，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var findNodes = function(callback){
 var nodeParent = document.getElementById(&quot;J_ul&quot;);
 var nodes = nodeParent.getElementsByTagName(&quot;li&quot;);
 var length = nodes.length;

 //判断参数callback是不是函数
 if(typeof callback !== &quot;function&quot;){
  callback = false;
 }

 while(length){
  length--;
  if(callback){
    callback(nodes[length]);// 这是回调函数可以操作部分
  }
 }

 return nodes; //还是可以返回节点
 }
 var hide = function(node){
  node.style.display = &quot;none&quot;;
  }
  var show = function(node){
  node.style.display = &quot;block&quot;;
  }

  findNodes(hide);
  findNodes(show);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 这里hide方法和show方法已经不需要再去遍历一回节点，相当于操作和需要操作的数据分离，其实有点像数据和控制器分离，这样做到findNodes方法更加&lt;code&gt;通用&lt;/code&gt;。&lt;/p&gt;

&lt;h3&gt;4.4 返回函数&lt;/h3&gt;

&lt;blockquote&gt;&lt;p&gt;函数是一个特殊变量，当有()的时候就是表示执行。执行完成之后就看有没有return，有的话就是这个函数返回出来的东西。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;函数里面还可以返回函数，但是这首先是函数执行之后的返回，也就是必须()，如果只是变量之间转换，例如：var a=fn;这样a是没有得到fn的返回值。这个只是a引用了fn。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var fn=function(){
    console.log(1);
    retunr function(){
     console.log(2);
    }
}
var a=fn;
var b=fn();
console.log(typeof a); // function,这个时候a只是fn的引用。
console.log(typeof b); // function，这个时候b是fn()执行完成之后的返回出来的function
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 如果fn执行完成之后没有返回值，即使赋值到变量上，变量也是undefind;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var fn = function(){
        console.log(1)      
    }   
    var a = fn;
    var b = fn();
    console.log(typeof a); // function,这个时候a只是fn的引用。
    console.log(typeof b); // undefined，因为fn()执行完成之后没有返回值，所以b得到对结果就是undefined;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数内部有一些私有的数据，在函数外部是访问不到，但是函数内部的函数是可以访问到，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var fn = function(){
    var count = 0; //该变量在fn外部访问不到，因为做用域的原因。
    return function(){
        count += 1; //这里可以访问到count，在函数内部。
    }
}
var a =fn();//这里执行过一次fn(),也就是初始化了一下count。
a(); //当第一次执行a()时，count已经初始化一次，因为a函数是fn里面的，所以能够访问到count变量。这个时候执行返回出来的函数。这里执行了也就是＋1。
a(); //2
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;这里有一个疑惑为什么第二次执行的时候不是1，而是2？&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;这里需要解释保存count为1的在哪里，这里就相当于开始的count=0,这是最开始的，也是执行一次就改变一次。这里可以理解count是相对返回的函数来说是一个全局变量。
例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var count = 0;
var add = function(){
    count += 1;
}
add();//这里每执行一次就改变全局变量count一次，只是前面那个例子是包含在一个函数内部。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;4.5 自定义函数&lt;/h3&gt;

&lt;p&gt;覆盖自己的函数定义，可以初始化操作一次。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var selfFn = function(){
        console.log(&quot;first&quot;);
        selfFn = funcition(){
            console.log(&quot;two&quot;);
        }
    }
    selfFn(); // first
    selfFn(); //two
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里是第一次执行的时候正常流程，并且把函数重新赋值到函数的名称，当第二次执行的时候，这个时候实际上，函数执行的内容已经覆盖开始到执行内容。函数被重定义。
函数是一个执行体，变量只是这个函数执行的引用。如果这个函数赋值给另外一个变量会怎样？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var otherFn = selfFn;
    otherFn();
    otherFn();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;4.6 自执行函数&lt;/h3&gt;

&lt;p&gt;一般这种函数是有一些只是执行一次，后面再也不执行了，并且可以保证在它里面的变量不会污染整个全局变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (function(){
        var who = &quot;juzipi&quot;;
        console.log(who);
    })() //这里括号完成表示执行

    //另外一种方式
    (function(){
    //do something
    }())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以给自执行函数加上参数，如果参数是window这样如果在浏览器的环境可以访问到全局的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var who = &#39;juzipi&#39;;
    (function(w){
        console.log(w.who); //juzipi
    })(window)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;为了通用型最好是不要用window作为参数，因为这个职能在浏览器的环境下执行&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4&gt;立即执行函数返回值&lt;/h4&gt;

&lt;p&gt;立即执行的函数也是可以返回值的，和他们函数一样。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var val = (function(){
        return 2+2;
    })()

    //可以省略括号

    var val = function(){
        return 2+2;
    }()

    //属性定义
    var obj ={
        m : (function(){
            var who = &quot;me&quot;;
            var what = &quot;call&quot;;
            return who +&quot;&quot;+what;
        })(),
        getM : function(){
            return this.m;
        }
    }

    obj.m;  //me call
    obj.getM();  //me call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里m这个属性值实际上是一个字符串，而getM是一个方法，所以要执行后得到结果。&lt;/p&gt;

&lt;h2&gt;立即初始化对象&lt;/h2&gt;

&lt;p&gt;建立一个对象，并且运行对象方法，对象字面量方式建立对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ({
        max : 2,
        min :1,
        add :function(){
            return max + min;
        },
        init : function(){
            return console.log(this.add());
        }
    }).init()
    //两种方式调用
    ({}).init();
    ({}.init());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实就是建立对象直接执行方法，如果初始化工作比较复杂，建议用这种方式，这种方式，结构比较清楚，是一次性初始化。
但是这种方式在js压缩工作工具里面不是很友好。&lt;/p&gt;

&lt;h2&gt;条件初始化&lt;/h2&gt;

&lt;p&gt;当知道某种条件在整个程序生命周期不会发生改变，这样就是对这个条件进行一次初始化操作就好，使用最多的就是浏览器特性检测。一般来说浏览器对于某种特性的支持都是固定的，不会存在变化的可能。比如对于事件的添加删除。
原来我们经常会这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var U = {
        addFn : function(el,type,fn){
            if(typeof window.addEventListener == &quot;function&quot;){
                el.addEventListener(type,fn,false);
            }else if(typeof document.attachEvent == &quot;function&quot;){
                el.attchEvnet(&quot;on&quot;+type, fn);
            }else{
                el[&quot;on&quot;+type] = fn;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这样效率不高，因为每次执行U.addFn()的时候都会去查一遍浏览器的特性，因为这个特性是固定的，所以不需要每一次都去查询一遍，只需要查询一次就可以。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var U = {
        addFn : null
        }

    if(typeof window.addEventListener == &quot;function&quot;){
        U.addFn = functon(el,type,fn){
            el.addEventListener(type,fn,false);
        }
    }esle if(typeof doucment.attachEvent == &quot;function&quot;){
        U.addFn = function(el,type,fn){
            el.attchEvent(&quot;on&quot;+type,fn)
        }
    }else{
        U.addFn = function(el,type,fn){
            el[&quot;on&quot;+type] = fn; //这里说明一下，为什么用中括号形式，而是“.”形式，因为后面那种形式不能使用字符串相加的运算
        }
    }   
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>学习笔记－设计模式－基础</title>
     <link href="http://beiyuu.com/Javascript%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0"/>
     <updated>2014-09-18T00:00:00+08:00</updated>
     <id>http://beiyuu.com/Javascript模式学习</id>
     <content type="html">&lt;h1&gt;Javascript模式学习&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2&gt;变量&lt;/h2&gt;

&lt;h3&gt;1、全局变量&lt;/h3&gt;

&lt;p&gt;都知道不能随便取全局变量，在浏览器中存在一个默认的一个全局对象this，还有一个全局的属性window，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var n = 2；
this.n; //2
this.window.n; //2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想要改变全局对象名称也可以随便在任何函数里面都可以&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; var global=(function(){
    return this;
 }())
 //重新命名全局对象的名称未global;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2、函数内变量会前置&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var n=&quot;blue&quot;;
function varFront(){
    consloe.log(n); //undefined
    var n = &quot;red&quot;; 
    console.log(n); //red
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我认为的第一个会是&lt;code&gt;blue&lt;/code&gt;，但是却是&lt;code&gt;undefined&lt;/code&gt;，因为&lt;code&gt;javascript&lt;/code&gt;的引擎机制的原因，会先创建变量、函数、参数，这个阶段是一个预编译的阶段，会扫描整个上下文，再来代码运行阶段，运行里面的函数表达式。在这一段代码中因为后面创建的变量和前面的全局变量是同名的，根据刚才的原则先创建变量再运算。&lt;/p&gt;

&lt;p&gt;实际就变成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var n=&quot;blue&quot;;
function varFront(){
    var n; //提前到前面
    console.log(n);
    var n = &quot;red&quot;;
    console.log(n); //rend

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;循环&lt;/h2&gt;

&lt;h3&gt;1、for&lt;/h3&gt;

&lt;p&gt;循环也是常用的一种语法方式，在开发中避免对于DOM操作时候多次寻找耗费资源&lt;/p&gt;

&lt;p&gt;比如有一个ul下面的li集合&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for（var i = 0; i&amp;lt;li.length;i++ ）{
    //li[i];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里每一次的读取i都回去重新找一遍li，而操作DOM是非常耗资源的一个事情，应该改成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var length=li.length;
for (var i=0; i&amp;lt;length; i++){
    //li[i]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存为一个变量存起来，就读取一次减少资源消耗。
再简化一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var i,li=[];
for(i=li.length;i--){
    //li[i]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里减少一个变量，并且是减量循环，减量循环比增量循环速度更快，解释是：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;因为和零比较要比和非零数字或数组长度比较要高效的多&lt;/code&gt;?这个没有很明白；
再有就是while循环&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var li=[],i=li.length;
while(i--){
    //li[li];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2、for-in&lt;/h3&gt;

&lt;p&gt;这个用来循环对象里面的属性，这里需要了解对象属性有两种情况，一种是原生一种prototype原型立案链集成。通过方法hasOwnProperty()去过滤。
实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var man={hands:2,head:1,legs:2},i;
if(Object.prototype.clone==&quot;undefined&quot;){
    Object.prototype.clone=function(){};
}
for(i in man){
    if(man.hasOwnProperty(i)){ 
    //通过hasOwnProperyt判断clone是不是原有的属性，还是通过prototype加进来的。这里如果运行到clone，通过的值是false；
        console.log(i, &quot;:&quot;, man[i]);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;不扩充内置原型&lt;/h3&gt;

&lt;p&gt;可以扩充构造函数的prototype的原型，可以给object()，添加新的方法，但是这种方式尽量不要使用因为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不好控制，和你一起开发的人员不知道你加了这么一个原型在里面，会不会重新覆盖，&lt;/li&gt;
&lt;li&gt;一个有可能新的EC版本增加新的方法和现在的方法冲突，&lt;/li&gt;
&lt;li&gt;就像上面那个object遍历如果不加hasOwnProperty()判断会遍历出来，这个和预想的结果不一样，而加了这个需要和你合作的每个开发人员说明。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;也有情况是可以加上的，就是未来EC版本会加上这个方法，你可以预先把这个实现了，并且和团队其他人员沟通过后，给出文档。&lt;/p&gt;

&lt;h3&gt;switch&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var i=0,t=&#39;&#39;;
switch (i){
case 1:
    t=&#39;不显示&#39;;
    break;
case 0:
    t=&#39;显示&#39;;
    break;
defalut:
    t=&#39;默认显示&#39;        
}
//显示
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;代码格式规范&lt;/h2&gt;

&lt;p&gt;团队之间代码格式规范是一个团队合作的基础&lt;/p&gt;

&lt;h1&gt;3、直接量和构造函数&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;这一章原来一直都有接触，但是并没有真正理解里面的运行逻辑，通过这一章的了解需要了解里面的运行逻辑是什么。并且对于直接量和构造函数之间的区别有所收获。&lt;/p&gt;

&lt;h2&gt;3.1 对象创建的三种形式&lt;/h2&gt;

&lt;h4&gt;一种是直接量例如：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;    //这里创建了一个空对象
    var o={}；
    //也可以给这个对象直接加上方法和属性。
    var o={
        name:&quot;juzi&quot;,
        age:12,
        title:function(){
            return &quot;工程师&quot;；
        }  //这里说明一下‘,&#39;该符号，可以在现代浏览器中加上，但是在IE中会报错
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;第二种就是根据内置的Object对象创建一个实例&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var o=new Object();
//创建一个数字对象
var n=new Object(2);
console.log(n.constructor === Number); // true
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;第三种是自定义构造函数&lt;/h4&gt;

&lt;p&gt;要好理解这种方式，就是把p当做Object来对待，相当于实例了一个p对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var p=function(){
    this.age=12;
    this.name=&#39;juzi&#39;;
    this.title=function(){
        return &quot;工程师&quot;；
    }
}

var p_01=new p();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际创建的过程：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建一个空的对象｛｝；并且把它引用赋给this，继承函数原型&lt;/li&gt;
&lt;li&gt;添加属性和方法给this&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回this指向的新对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  var p = function(){
      //this={}
      this.age = 12;
      this.name = &quot;juzi&quot;;
      this.title = function(){
          return &quot;工程师&quot;
      }
      //return this;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;构造函数返回值&lt;/h4&gt;

&lt;p&gt;当用new调用一个构造函数的时候，其实调用的是这个构造函数里面的返回的对象，可以自定义返回的对象，如果没有定义的话，默认返回的事this这个对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var p ＝ function(){
        this.name=&quot;juzi&quot;;
        var that = {};
        that.name = &quot;juzipi&quot;;
        return that;
    }
    var me = new p();
    me.name;  // juzipi
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;如果返回的不是对象，是字符串，数字，布尔值，程序不会抱错，这个值会被忽略，最终还是返回this所指的对象。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4&gt;如果没有使用new&lt;/h4&gt;

&lt;p&gt;没有使用new的时候，函数内部的this实际上面指的是全局对象，如果是在浏览器里面指的就是window对象，这个并不是我们想要的效果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var p = function(){
        this.name = &quot;juzi&quot;;
    }
    var me = new p(); // suc
    var me = p();
    console.log(typeof me);  //undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以这就需要我们在用函数命名的时候，有一个约定，不然自己搞混了，函数开始字母用小写（myFunction），构造函数就用大写（MyFunction）。&lt;/p&gt;

&lt;h4&gt;使用that&lt;/h4&gt;

&lt;p&gt;为了避免忘记new等一些错误写法，可以全部返还that这个对象，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var p = function(){
        var that = {}
        that.name = &quot;juzi&quot;;
        return that;
    }
    var me = p();
    me.name; //juzi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候就不会发生错误，能够得到里面的值，但是这个有一个问题，不能继承方法的原型。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;这里的that可以是任何的字&lt;/p&gt;&lt;/blockquote&gt;
</content>
   </entry>
   
   <entry>
     <title>模块化学习思考</title>
     <link href="http://beiyuu.com/%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%80%83"/>
     <updated>2014-09-05T00:00:00+08:00</updated>
     <id>http://beiyuu.com/学习思考</id>
     <content type="html">&lt;h1&gt;模块化思考&lt;/h1&gt;

&lt;p&gt;最近看了一些模块化相关的库或者是文章，本文的目的也是给自己里一个头绪，到底怎样才能真正推行到团队里面的模块化，这个概念说了这么久，现在这两年开始真正推行起来。&lt;/p&gt;

&lt;p&gt;作为一个由美工转过来的前端，我知道我自己在编程这一块是我的弱项。不过这两年发现前端慢慢转到工程化这个阶段，在这方面我还是能够提升。&lt;/p&gt;

&lt;p&gt;原来我一直说是自动化其实最近，我越来越感觉应该是一个工程化的概念，甚至可以说是一个系统工程。&lt;/p&gt;

&lt;p&gt;原来我们的初级阶段的模块化，按照功能模块把，html和css分割开来，&lt;/p&gt;

&lt;p&gt;HTML：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul class=&#39;Module&#39;&amp;gt;
    &amp;lt;li&amp;gt;Tab 1&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;Tab 2&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;Tab 3&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CSS：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.Module li{..}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么后面调用这个CSS和HTML就组成一个模块，但是这个没有解决几个问题，如果里面有交互牵涉到js怎么模块化，这里只是CSS和HTML。&lt;/p&gt;

&lt;p&gt;后面用到百度的fis，这个工具我自己的给它的定位就是管理并且发布静态资源。解决的是静态资源的问题，&lt;/p&gt;

&lt;h3&gt;js加载模块化&lt;/h3&gt;

&lt;p&gt;在js加载这一块目前国内说得比较多的是Requery.js和seajs这两个加载库，给我感觉作用差不多，只不过require和seajs神明模块的方式不同&lt;/p&gt;

&lt;h3&gt;require&lt;/h3&gt;

&lt;p&gt;申明方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,function(&quot;modelA&quot;,&quot;modelB&quot;,&quot;modelC&quot;){

})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用方式：&lt;/p&gt;

&lt;h3&gt;seajs&lt;/h3&gt;

&lt;p&gt;申明方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports, module) {

// 引用moduleA.js文件
var module=require(./moduelA);


});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用方式：&lt;/p&gt;

&lt;p&gt;但是这种模块加载会演变成一个问题，每一个模块都是一个js文件，一个项目可能会有几十个文件，这样导致浏览器请求增加太多，对性能有所影响，这时候就需要合并js文件。&lt;/p&gt;

&lt;p&gt;模块化加载》合并文件》这样也会产生一个问题，根据页面的功能不同，怎样加载不同页面并且还不会重复加载。
比如&lt;code&gt;a.html&lt;/code&gt;页面功能有&lt;code&gt;a.js&lt;/code&gt; &lt;code&gt;b.js&lt;/code&gt; &lt;code&gt;c.js&lt;/code&gt;,合并成一个文件.&lt;/p&gt;
</content>
   </entry>
   
 
</feed>
