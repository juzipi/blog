<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>juzipi</title>
   <link href="/blog/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="/blog" rel="alternate" type="text/html" />
   <updated>2016-05-12T14:52:12+08:00</updated>
   <id>/blog</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>webpack使用方法</title>
     <link href="http://beiyuu.com/webpack%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"/>
     <updated>2016-02-25T00:00:00+08:00</updated>
     <id>http://beiyuu.com/webpack基础使用</id>
     <content type="html">&lt;h2&gt;webpack基础使用&lt;/h2&gt;

&lt;h3&gt;基本概念&lt;/h3&gt;

&lt;p&gt;也是一个脚手架工具，和原来的grunt和gulp作用相似，但是又有新的改进，更是现在因为react流行后，配合度最好的一个构建工具。&lt;/p&gt;

&lt;p&gt;前端资源模块化管理和打包工具，（这里强调的是两个作用一个管理一个是打包），不要认为就是一个打包工具。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将原来一些松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。&lt;/li&gt;
&lt;li&gt;可以按需加载模块进行代码分离，等到实际需要再异步加载

&lt;blockquote&gt;&lt;p&gt;怎样实现的按需加载？&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;通过loader的转换，任何形式的资源都可以视做模块，比如CommonJs模块、AMD模块、ES6模块、css、图片、josn、Less、Sass等。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;一图胜万言，把官网的图拿过来&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/juzipi/blog/gh-pages/_posts/tool/webpack.png&quot; alt=&quot;webpack&quot; /&gt;&lt;/p&gt;

&lt;p&gt;把各种资源整合整合到最后，不管是js、css、图片，最后通过webpack输出成需要的文件。&lt;/p&gt;

&lt;h3&gt;现状&lt;/h3&gt;

&lt;p&gt;前端资源管理，一直都是一个比较难的难题，和后台管理不同，他面临的资源种类复杂，包括html、css、图片、js，这四样基本的东西，并且各自都交叉融合。&lt;/p&gt;

&lt;p&gt;项目小的时候，还不能体现复杂性，当一个项目大的时候，就需要考虑模块化重复利用，特别是现在webapp，或者是单页应用越来越多的时候，按需加载这个需求就是必然会产生，手机端对于流量和页面渲染的速度要求更加高。&lt;/p&gt;

&lt;p&gt;现在的js规范也有多种多样AMD、CMD、ES6等等，当项目上线的时候需要有一个能够整合所有gef&lt;/p&gt;

&lt;p&gt;这也是这几年前端界一直都是在解决的问题，很早有百度的fis，现在有webpack。这也是这两年刚刚推出来的一个脚手架工具。&lt;/p&gt;

&lt;h2&gt;安装&lt;/h2&gt;

&lt;p&gt;需要先安装node才能，node自带npm管包工具。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install webpack -g
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;全局安装&lt;/p&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;$ npm install webpack --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;安装到本文件夹，并且写入&lt;code&gt;package-json&lt;/code&gt;文件中&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;快速使用&lt;/h2&gt;

&lt;p&gt;编译js文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;//entry.js
document.write(&quot;first&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;webpack entry.js module.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会得到一个编译后的文件module.js，但是这是最简单的一种方式，一般真实的使用场景中是用配置文件来管理。下面就来看看配置文件怎么来做。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;/app

&lt;ul&gt;
&lt;li&gt;entry.js&lt;/li&gt;
&lt;li&gt;module.js&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;package.json&lt;/li&gt;
&lt;li&gt;webpack.config.js&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;上面是一个基本的实例文件分布，实际项目中要比这复杂的多，现在有入口文件 &lt;code&gt;entry.js&lt;/code&gt;，需要加载的模块&lt;code&gt;module.js&lt;/code&gt;，一个node的配置文件，一个webpack配置文件。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>前端规范的思考</title>
     <link href="http://beiyuu.com/javascript%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83"/>
     <updated>2016-01-01T00:00:00+08:00</updated>
     <id>http://beiyuu.com/javascript代码规范</id>
     <content type="html">&lt;h2&gt;Javascript代码规范&lt;/h2&gt;

&lt;h4&gt;遵守严格模式下的代码规范，因为ES6自动采用严格模式，不管模块头部是不是加了“use strict”,&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;变量必须声明后再使用&lt;/li&gt;
&lt;li&gt;函数的参数不能有同名属性，否则报错&lt;/li&gt;
&lt;li&gt;不能使用 &lt;code&gt;with&lt;/code&gt; 语句&lt;/li&gt;
&lt;li&gt;不能对只读属性赋值，否则报错&lt;/li&gt;
&lt;li&gt;不能使用前缀0表示八进制数，否则报错&lt;/li&gt;
&lt;li&gt;不能删除不可删除的属性，否则报错&lt;/li&gt;
&lt;li&gt;不能删除变量&lt;code&gt;delete prop&lt;/code&gt;，会报错，只能删除属性&lt;code&gt;delete global[prop]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eval&lt;/code&gt;不会在它的外层作用域引入变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eval&lt;/code&gt;和&lt;code&gt;arguments&lt;/code&gt;不能被重新赋值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arguments&lt;/code&gt;不会自动反映函数参数的变化&lt;/li&gt;
&lt;li&gt;不能使用&lt;code&gt;arguments.callee&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不能使用&lt;code&gt;arguments.caller&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;禁止&lt;code&gt;this&lt;/code&gt;指向全局对象&lt;/li&gt;
&lt;li&gt;不能使用&lt;code&gt;fn.caller&lt;/code&gt;和&lt;code&gt;fn.arguments&lt;/code&gt;获取函数调用的堆栈&lt;/li&gt;
&lt;li&gt;增加了保留字（比如&lt;code&gt;protected&lt;/code&gt;、&lt;code&gt;static&lt;/code&gt;和&lt;code&gt;interface&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>promise对象</title>
     <link href="http://beiyuu.com/promise"/>
     <updated>2015-10-13T00:00:00+08:00</updated>
     <id>http://beiyuu.com/promise</id>
     <content type="html">&lt;h3&gt;一、概述&lt;/h3&gt;

&lt;p&gt;在解释promise对象之前，先了解，js中异步的概念。
js语言的执行环境是&quot;单线程&quot;,也就是一次只能执行一个任务,如果任务多了,就需要排队,前面任务完成才能执行后面的任务.例如：&lt;/p&gt;

&lt;h4&gt;同步和异步：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;同步是一个任务完成执行下一个任务,每一个任务按照顺序来执行。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;异步是简而言之，任务执行顺序和排列的任务顺序不一致。假设有A和B两个任务，顺序是A&gt;B。A任务里面分为两段代码，一段是对外部的数据的请求，一段是一个回调函数。第一段执行完成不是立刻执行第二段代码，而是会到B任务等外部数据返回回来，再执行第二段代码。&lt;/p&gt;

&lt;p&gt;  var f1 = function(fn){
      console.log(&quot;1&quot;);
      setTimeout(fn, 1000);//向外部发送请求，fn就是回调函数。但是这里配置的是一秒后再执行。
  }
  var f2 = function(){
      console.log(&quot;2&quot;)
  }
  //再执行f2函数一秒之前，f3会执行。
  var f3 = function(){
      console.log(&quot;3&quot;);
  }
  f1(f2)
  f3();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;打印出来的结果是1&gt;3&gt;2，这里任务排列是f1&gt;f2&gt;f3但是真正执行的时候顺序改变了,这就是&quot;异步模式&quot;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;上面回调模式是建立在f2执行时间比较长，有可能会影响f3执行，不过这种模式缺点比较明显，不容易阅读，回调函数的名称必须写多了，作用是什么可能不是很清楚，而且每一种任务，只能有一个回调函数。&lt;/p&gt;

&lt;h4&gt;异步的流程控制&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var async = function (arg,callback){
    console.log(&quot;参数为&quot;+arg+&quot;一秒后返回&quot;);
    setTimeout(function(){callback(arg+1);}, 1000);
}

var final = function (value) {
    console.log(&#39;完成: &#39;, value);
}
async(1,function(value){
    async(value,final)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;首先第一次执行async代码，执行里面的内容。&lt;/li&gt;
&lt;li&gt;一秒钟后再执行callback函数，这里callback函数就是执行async，第二遍执行，里面内容，并且取函数的第一个参数值+1.&lt;/li&gt;
&lt;li&gt;第二遍执行async里面的函数的callback函数，这里函数就是final&lt;/li&gt;
&lt;li&gt;&lt;p&gt;final函数的会取value为参数。
这里会在执行完两遍async函数后再执行final，也就是两秒之后，这只是一层的嵌套，如果多几层嵌套，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  async(1, function(value){
      async(value, function(value){
          async(value, function(value){
              async(value, function(value){
                  async(value, function(value){
                  async(value, final);
                  });
              });
          });
      });
  });
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;串行执行&lt;/h3&gt;

&lt;p&gt;串行执行可以是一个任务完成再来执行另外一个任务，可以用来控制异步任务。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var items = [ 1, 2, 3, 4, 5, 6 ];
var results = [];
function series(item) {
  if(item) {
    async( item, function(result) {//这里的result也是item+1的值
      results.push(result);
      return arguments.callee(items.shift());
      //返回并且再次执行自身一遍。
    });
  } else {
    return final(results);
    //如果数组中没有项目，则执行final
  }
}

series(items.shift());
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;并行执行&lt;/h3&gt;

&lt;p&gt;也就是一同把所有的函数执行完成，再执行final，这个在效率上面有提升，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;items.forEach(function(item){
    async(item,function(reulse){
        results.push(reulse);
        if(results.length == items.length){
            final(reulses)
        }
    })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方式和前面串行方式不同的是，不需要等待前面一个执行完成执行后面那个任务，可以同时进行，但是这个也有一个弊端就是当同时进行的任务过多，给机器带来的性能压力就会体现出来。需要有一种结合这两种方式的更好的方法出来&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function launcher(){
    while(running &amp;lt; limit &amp;amp;&amp;amp; items.length &amp;gt; 0){
        var item = items.shift();
        async(item,function(result){
            results.push(result);
            running--;
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二、 Promise&lt;/p&gt;

&lt;h3&gt;概述&lt;/h3&gt;
</content>
   </entry>
   
   <entry>
     <title>装饰性模式</title>
     <link href="http://beiyuu.com/%E8%A3%85%E9%A5%B0%E6%80%A7%E6%A8%A1%E5%BC%8F"/>
     <updated>2015-09-10T00:00:00+08:00</updated>
     <id>http://beiyuu.com/装饰性模式</id>
     <content type="html">&lt;h2&gt;一、理解&lt;/h2&gt;

&lt;p&gt;在不改变原有的函数的基础上，添加新功能。也可以有继承的方式添加新的功能，但是那样会有一个子类和超类，子类依赖与超类。
有时候不想去改变原有的功能，就需要用到这种装饰者模式。
一个简单实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = function(){
    consol.log(&quot;a&quot;);
}
//为了不影响a函数，而又要在a函数基础上添加新的功能，可以如此：

var _a = a;
var a = function(){
    _a();
    console.log(&quot;aa&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里重写了一下a函数，让它加上新的功能，又对原来的函数没有改动。但是这种方式感觉还是不够好，一个函数名称没有改变，对于代码维护来说不知道那个是后来a那个是前面a。
还有一个_a需要去维护，万一添加的功能多了，或者a里面其实还有功能添加，这个时候维护起来就是一个噩梦了。
三是有一个this劫持的问题。如果a函数中用到this，那么在新的函数中this指向可能就会有问题，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//保存方法
var _getId = document.getElementById;

document.getElementById = function(id){
//添加新功能
    console.log(&quot;新功能&quot;);
//执行原来保存的方法
    return _getId(id); //报错：Illegal invocation    
}
var btn = document.getElementById(&quot;btn&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为该方法的执行环境必须是在document下面，这里重新覆盖的，this已经不是document而是window所以报错。可以改成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document.getElementById = function(id){
    console.log(&quot;新功能&quot;);
    return _getId.apply(document,arguments);    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二、用AOP装饰&lt;/p&gt;

&lt;p&gt;通过高阶函数，可以实现一些更加松散的方法，也更友好。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Function.prototype.after = function(fn){
    var _self = this;//保存原来的函数
    return function(){
        var ret = _self.apply(this,arguments);
        fn.apply(this,arguments);
        return ret;
    }
}

Function.prototype.before = function(fn){
    var _self = this;
    return function(){
        fn.apply(this,arguments);
        return _self.apply(this,arguments);
    }       
}

var a = function(){
    console.log(&quot;a&quot;);
}

var b = function(){
    console.log(&quot;b&quot;);
}

var _a = a.after(b);    
_a(); // ab

var _b = a.before(b);
_b(); //ba
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面两个方法，对于函数来说更加友好，不会去改变原有函数名称，并且动态的去添加新的功能。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>15年08月19日－周工作记录</title>
     <link href="http://beiyuu.com/%E5%91%A8%E7%BA%AA%E5%BD%95"/>
     <updated>2015-08-19T00:00:00+08:00</updated>
     <id>http://beiyuu.com/周纪录</id>
     <content type="html">&lt;p&gt;2015年08月19日&lt;/p&gt;

&lt;p&gt;本周工作学习心得：&lt;/p&gt;

&lt;h3&gt;一、垂直居中对齐&lt;/h3&gt;

&lt;p&gt;需求：在弹出框中对内容进行垂直居中定位&lt;/p&gt;

&lt;p&gt;状况：内容高度不定，&lt;/p&gt;

&lt;p&gt;解决方法：&lt;/p&gt;

&lt;p&gt;1、原来的解决方案，算出内容高度，然后用绝对定位，加上负边距实现&lt;/p&gt;

&lt;p&gt;2、现有移动端的实现方式更加简单&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.box{display:flex; display:-webkit-flex;}
.item{align-self:center;-webkit-align-self:center;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是要兼容更加低端的手机还需要用box这个老属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.box{
    display:box; display:-webkit-box;
    box-align:center; -webkit-box-align:center;
    display:flex; display:-webkit-flex;

}
.item{align-self:center;-webkit-align-self:center;}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;经常会遇到flex一些老浏览器和手机不支持情况，这个时候可以用box这个老的属性，兼容实现。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3&gt;二、数字自动转译&lt;/h3&gt;

&lt;p&gt;需求：在手机端点击输入框出来数字键盘&lt;/p&gt;

&lt;p&gt;问题：当输入到一定数字时候，数字自动转译&lt;/p&gt;

&lt;p&gt;解决方案：把number类型改成tel类型。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;该方案对于一些原生的placeholer支持也有作用，一些number对于placeholer支持不太好&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3&gt;三、angularJS 过滤&lt;/h3&gt;

&lt;p&gt;定义过滤器：对字符进行重新转换的过程。
自定义和使用过滤&lt;/p&gt;

&lt;p&gt;使用过滤服务：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.233 // 1.23保留两位小数点
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自定义服务：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myAppMoudel = angular.module(&quot;myApp&quot;,[]);
myAppMoudel.filter(&quot;addNum&quot;,function(){
    return function(item){
    //这里item指需要转换的字符
        return item+1;
    }
})

2 // 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;四、angularJS 服务&lt;/h3&gt;

&lt;p&gt;模版：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;body ng-app=&quot;myApp&quot;&amp;gt;
    &amp;lt;div ng-controller=&quot;test&quot;&amp;gt;
        &amp;lt;input type=&quot;button&quot; ng-click=&quot;show()&quot; value=&quot;点击&quot; /&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建立自定义服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myAppModule = angular.module(&quot;myApp&quot;,[]);
myAppModule.factory(&quot;myService&quot;,function(){
    return {
        fn:function(){
            console.log(&quot;self&quot;);
        }
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引用服务：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;自定义的服务一定是放在左右服务最后面。&lt;/p&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;myAppModule.controller(&quot;test&quot;,[&quot;$scope&quot;,&quot;myService&quot;,function($scope,myService){

$scope.show =function(){
    myService.fn();
}

}])
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>离线缓存(manifest)</title>
     <link href="http://beiyuu.com/%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98"/>
     <updated>2015-08-11T00:00:00+08:00</updated>
     <id>http://beiyuu.com/离线缓存</id>
     <content type="html">&lt;h1&gt;离线缓存(manifest)&lt;/h1&gt;

&lt;h2&gt;基本配置&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;CACHE MANIFEST
# version xx.xx.xx
CACHE:    //需要缓存的文件
needBeCached.png
needBeCached2.js

NETWORK:   //需要缓存，随时和服务器链接
notNeedBeCached.html
notNeedBeCached2.css

FALLBACK:  //备用资源，当资源无法访问，通过这个访问
/ 404.html
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;坑&lt;/h2&gt;

&lt;h3&gt;manifest除了缓存manifest.appcache文件所指定的资源外，还必定会缓存当前的html页面。&lt;/h3&gt;

&lt;p&gt;具体来说：&lt;/p&gt;

&lt;p&gt;当用户第一次访问页面，会从服务器上拉取html页面，以及其它静态资源。
浏览器会把html页面，连同manifest.appcache文件，连同manifest.appcache文件里所指定的静态资源一并存入Application Cache。
当用户第二次访问该页面，manifest.appcache文件里所指定的静态资源就不需要重新加载了，直接从cache读出。这很好，问题是，当前的html页面也从cache直接读出来了，根本就不管线上的版本呀！
这造成的问题是，网站如果更新了，用户的浏览器根本不知道，还显示cache里的版本&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>jekyll基本使用方式</title>
     <link href="http://beiyuu.com/jekyll%E4%BD%BF%E7%94%A8"/>
     <updated>2015-06-25T00:00:00+08:00</updated>
     <id>http://beiyuu.com/jekyll使用</id>
     <content type="html">&lt;h2&gt;基本使用方式&lt;/h2&gt;

&lt;p&gt;安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem install jekyll
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入文件夹&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jekyll new my-site
cd my-site
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jekyll serve

服务地址：http://localhost:4000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建立&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jekyll build

jekyll build -watch //持续跟踪
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文章要求&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: post
title: jekyll基本使用方式
description: jekyll基本使用方式
category: blog
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
</content>
   </entry>
   
   <entry>
     <title>原型理解</title>
     <link href="http://beiyuu.com/%E5%8E%9F%E5%9E%8B%E7%90%86%E8%A7%A3"/>
     <updated>2014-12-17T00:00:00+08:00</updated>
     <id>http://beiyuu.com/原型理解</id>
     <content type="html">&lt;h1&gt;原型解析&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;什么是原型?&lt;/li&gt;
&lt;li&gt;原型的作用是什么？&lt;/li&gt;
&lt;li&gt;堆和栈的区别？&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;1.对象分类&lt;/h2&gt;

&lt;p&gt;在js中有一个概念就是一切皆是对象，但是对象也有分不同的类型
先抛出几个问题在这篇文章中去解答：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;普通对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; var o = new Object();
 var o1 = {};
 var ff=function(){}; var o2=new ff();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; var f=function(){};
 var f1=Function(&quot;sopit&quot;,&quot;alert(&#39;a&#39;)&quot;);
 function f2(){}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原型对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; //源码

 function myFun(){
     var name=&quot;juzi&quot;;
 }

 function myFunPro(){
     this.name=&quot;juzi&quot;;
     this.t=function(){
         return &quot;tt&quot;;
     }
 }

 myFunPro.prototype.title=function(){
     return &quot;biaoti&quot;;
 }

 var m=new myFun();

 myFun.prototype=m;

 var u=i=m;

 var mP=new myFunPro();

 var o=new Object();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;blockquote&gt;&lt;p&gt;顺便说几个方法&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;tpyeof 可以知道数据类型，number,object,function,undefinded,boolean,string
 判断变量是否存在，使用typeof，例如：&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    if(a){alert(&quot;a&quot;);} //有抱错信息
    if(typeof !=&quot;undefined&quot;){ alert(&quot;a&quot;); } //不会报错
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;instanceof 可以判断是否是实例，例如： a instanceof A；输出的事一个布尔值&lt;/li&gt;
&lt;/ol&gt;


&lt;blockquote&gt;&lt;/blockquote&gt;

&lt;p&gt;我想到这里可以说一下原型有什么作用了：
1. 用来继承减少空间占用&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>AngularJS应用－基础概念</title>
     <link href="http://beiyuu.com/AngularJS%E5%AE%9E%E6%88%98-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"/>
     <updated>2014-09-23T00:00:00+08:00</updated>
     <id>http://beiyuu.com/AngularJS实战－基础概念</id>
     <content type="html">&lt;h2&gt;一、MVC 框架&lt;/h2&gt;

&lt;p&gt;所有实例基本框架：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;body ng-app=&quot;MyModule&quot;&amp;gt;
    // content...
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;二、基本概念&lt;/h2&gt;
</content>
   </entry>
   
   <entry>
     <title>AngularJS应用－指令</title>
     <link href="http://beiyuu.com/AngularJS-%E6%8C%87%E4%BB%A4"/>
     <updated>2014-09-23T00:00:00+08:00</updated>
     <id>http://beiyuu.com/AngularJS-指令</id>
     <content type="html">&lt;h2&gt;一、基本概念&lt;/h2&gt;

&lt;p&gt;说明概念：附加在HTML元素上面自定义标记，可以是：标签、属性、class类，通过AngularJS的HTML编辑器（$compile），在指定元素上面附加指定的行为，可以操作DOM，改变DOM元素，甚至它子节点。&lt;/p&gt;

&lt;p&gt;一般都是用ng开始，表示指令。
部分内置指令：ngBind,ngModle,ngView,ngClick等。
指令匹配形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 推荐使用方式
&amp;lt;span ng-bing=&quot;name&quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;span ng:bind=&quot;name&quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;span ng_bind=&quot;name&quot;&amp;gt;&amp;lt;/span&amp;gt;
// 符合HTML验证，（data）
&amp;lt;span data-ng-bind=&quot;name&quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;span x-ng-bing=&quot;name&quot;&amp;gt;&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;二、应用&lt;/h2&gt;

&lt;h3&gt;2.1 注册指令：&lt;/h3&gt;

&lt;p&gt;基本方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.directive(&quot;dir&quot;,function(){
    return {

    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般返回一个匿名的对象&lt;/p&gt;

&lt;p&gt;替换内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;&quot; ng-controller=&quot;de&quot;&amp;gt;
    &amp;lt;hello&amp;gt;&amp;lt;/hello&amp;gt;
&amp;lt;/div&amp;gt;

//定义了一个hello指令
var MyModule = angular.module(&quot;MyModule&quot;,[]);
MyModule.directive(&quot;hello&quot;,function(){
    return {
        restrict : &quot;E&quot;,
        template : &quot;&amp;lt;div&amp;gt;替换了&amp;lt;/div&amp;gt;&quot;,
        replace : true
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;restrict 可以是四个值：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;E：表示元素标签，&lt;hello&gt;&lt;/hello&gt;&lt;/li&gt;
&lt;li&gt;A：表示属性(默认属性), &lt;div hello&gt;&lt;/hello&gt;&lt;/li&gt;
&lt;li&gt;M：表示注释, &lt;!-- directive: hello --&gt;&lt;/li&gt;
&lt;li&gt;C：表示样式（class）,&lt;div class=&quot;hello&quot; &gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;遇到一个问题，样式（C）时，使用在input输入框，不能用“－”并且在指令名称中不能用大写，如果标签中是大写，那么在注册的时候需要改成小写。
但是不能input框，可以注册用大写。没有找到规律&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3&gt;2.2 保留原有内容，并且增加内容：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;MyModule.directive(&quot;hello&quot;,function(){
    return {
        restrict : &quot;E&quot;,
        transclude : true,
        template : &quot;&amp;lt;div&amp;gt;添加内容&amp;lt;div ng-transclude&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&quot;
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2.3 引用html模版&lt;/h3&gt;

&lt;p&gt;当有大量的html需要修改或者替换的时候可用，引用html模版文件，这样减少在js中写大量到html代码，并且还需要考虑拼接：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MyModule.directive(&quot;hello&quot;,function(){
    return {
        restrict : &quot;E&quot;,
        templateUrl : &quot;hello.html&quot;,
        replace : true
    }
})
&amp;lt;-- hello.html --&amp;gt;
&amp;lt;div&amp;gt;替换内容&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;这里可以考虑一些常用的html模块，直接用这种方式，给一个指令直接就把需要的html结构给出来，但是这里还牵涉到一个css，和这个模块要用到的js。参考fis&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;缓存模版，当有一些模版会重复使用到到的时候可以使用缓存模版方式，主要是牵涉到几个方法，put、get&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//注射器加载完所有模块时，此方法执行一次，run。
MyModule.run(function($templateCache){

    //put设置缓存模版，第一参数定义名称，第二个是内容。
    $templateCache.put(&quot;h&quot;,&quot;&amp;lt;div&amp;gt;缓存内容&amp;lt;/div&amp;gt;&quot;);

})

//获取缓存的内容
MyModule.directive(&quot;hello&quot;,function(){
    return {
        restrict : &quot;E&quot;,
        replace : true,
        template : $templateCache.get(&quot;h&quot;)
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2.4 LINk方法：&lt;/h3&gt;

&lt;p&gt;参数有四个分别是scope,element,attr,ctrl&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 指令 link使用 --&amp;gt;
&amp;lt;!-- 定义controller --&amp;gt;
&amp;lt;div class=&quot;&quot; ng-controller=&quot;myLoad&quot;&amp;gt;
    &amp;lt;load class=&quot;btn-deep-blue mt-vbig&quot;&amp;gt;测试加载&amp;lt;/load&amp;gt;
    &amp;lt;div id=&quot;show&quot;&amp;gt;显示&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义contraoller里面的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myLoadModule = angular.module(&quot;MyModule&quot;,[]);
myLoadModule.controller(&quot;myLoad&quot;,[&quot;$scope&quot;,function($scope){

    $scope.loadData = function(){
        angular.element(document.querySelector(&quot;#show&quot;)).addClass(&quot;btn-deep-blue&quot;);
        console.log(&quot;加载。。&quot;);
    }

}]);

//定义指令
    myLoadModule.directive(&quot;load&quot;,function(){
    return {
        restrict:&quot;E&quot;,
        link : function(scope,element,attr){
                element.bind(&quot;click&quot;,function(){
//这里的scope相当于和控制器中的$scope相连接了，能够获取到控制中的方法，通过$scope中转站衔接
                    scope.loadData();
                    // 作用相同:
                    // scope.$apply(&quot;loadData()&quot;)
                })

        }
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2.5 指令复用&lt;/h3&gt;

&lt;p&gt;通过link中的attr属性去复用指令&lt;/p&gt;

&lt;p&gt;HTML:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;&quot; ng-controller=&quot;myLoad1&quot;&amp;gt;
    &amp;lt;loading class=&quot;btn-deep-blue mt-vbig&quot; loadfn=&quot;loadData()&quot;&amp;gt;测试加载&amp;lt;/loading&amp;gt;
&amp;lt;/div&amp;gt;  
&amp;lt;div class=&quot;&quot; ng-controller=&quot;myLoad2&quot;&amp;gt;
    &amp;lt;loading class=&quot;btn-deep-blue mt-vbig&quot; loadfn=&quot;loadData2()&quot;&amp;gt;测试加载2&amp;lt;/loading&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JS:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 控制器定义
var MyModule = angular.module(&quot;MyModule&quot;,[]);
MyModule.controller(&quot;myLoad1&quot;,[&quot;$scope&quot;,function($scope){
    $scope.loadData = function(){
        console.log(&quot;加载。。1&quot;);
    }
}]);

MyModule.controller(&quot;myLoad2&quot;,[&quot;$scope&quot;,function($scope){
    $scope.loadData2 = function(){
        console.log(&quot;加载。。2&quot;);
    }
}]);

// 指令定义
myLoadModule.directive(&quot;load&quot;,function(){
    return {
        restrict:&quot;E&quot;,
        link : function(scope,element,attr){
                element.bind(&quot;click&quot;,function(){
                    scope.$apply(attr.loadfn)
        // 这里loadfn注意要小写
                })

        }
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2.6 指令间的调用&lt;/h3&gt;

&lt;p&gt;这里说一下另外一个方法：controller&lt;/p&gt;

&lt;p&gt;HTML:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
    &amp;lt;superman strength&amp;gt;力量&amp;lt;/superman&amp;gt;
    &amp;lt;superman strength speed&amp;gt;力量、速度&amp;lt;/superman&amp;gt;
    &amp;lt;superman strength speed light&amp;gt;力量、速度、光&amp;lt;/superman&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的controller是指令内部的，是暴露一些方法给外部调用:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 指令间调用
MyModule.directive(&quot;superman&quot;,function(){
    return {
        //独立作用域
        scope:{},
        restrict: &quot;AE&quot;,
        controller: function($scope){
            $scope.abilities=[];
            // 这里的this指的是？这里看是调用这个controller方法的对象，通过下面的调用知道，这是指令对象
            this.addStrength=function(){
                $scope.abilities.push(&quot;strength&quot;);
            }
            this.addSpeed=function(){
                $scope.abilities.push(&quot;speed&quot;);
            }
            this.addLight=function(){
                $scope.abilities.push(&quot;light&quot;);
            }
        },
        link : function(scope,element,attr){
            element.addClass(&quot;btn-deep-blue mt-tiny&quot;);
            element.bind(&quot;click&quot;,function(){
                console.log(scope.abilities);
            })
        }
    }
});

MyModule.directive(&quot;strength&quot;,function(){
    return {
        //require 引用了一个指令对象
        require: &quot;^superman&quot;,
        // link最后一个参数是传入 require引用的对象
        link: function(scope,element,attr,s){
            s.addStrength();
        }
    }
});
MyModule.directive(&quot;speed&quot;,function(){
    return {
        require: &quot;^superman&quot;,
        link: function(scope,element,attr,supermanCtrl){
            supermanCtrl.addSpeed();
        }
    }
});
MyModule.directive(&quot;light&quot;,function(){
    return {
        require: &quot;^superman&quot;,
        link: function(scope,element,attr,supermanCtrl){
            supermanCtrl.addLight();
        }
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;什么时候用controller什么时候用link，link指指令内部，做一个绑定事件，或者一些事件的处理，而controller是给外部调用&lt;/p&gt;&lt;/blockquote&gt;
</content>
   </entry>
   
 
</feed>
