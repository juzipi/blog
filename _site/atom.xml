<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>juzipi</title>
   <link href="/blog/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="/blog" rel="alternate" type="text/html" />
   <updated>2016-02-24T17:14:12+08:00</updated>
   <id>/blog</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>前端规范的思考</title>
     <link href="http://beiyuu.com/javascript%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83"/>
     <updated>2016-01-01T00:00:00+08:00</updated>
     <id>http://beiyuu.com/javascript代码规范</id>
     <content type="html">&lt;h2&gt;Javascript代码规范&lt;/h2&gt;

&lt;h4&gt;遵守严格模式下的代码规范，因为ES6自动采用严格模式，不管模块头部是不是加了“use strict”,&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;变量必须声明后再使用&lt;/li&gt;
&lt;li&gt;函数的参数不能有同名属性，否则报错&lt;/li&gt;
&lt;li&gt;不能使用with语句&lt;/li&gt;
&lt;li&gt;不能对只读属性赋值，否则报错&lt;/li&gt;
&lt;li&gt;不能使用前缀0表示八进制数，否则报错&lt;/li&gt;
&lt;li&gt;不能删除不可删除的属性，否则报错&lt;/li&gt;
&lt;li&gt;不能删除变量delete prop，会报错，只能删除属性delete global[prop]&lt;/li&gt;
&lt;li&gt;eval不会在它的外层作用域引入变量&lt;/li&gt;
&lt;li&gt;eval和arguments不能被重新赋值&lt;/li&gt;
&lt;li&gt;arguments不会自动反映函数参数的变化&lt;/li&gt;
&lt;li&gt;不能使用arguments.callee&lt;/li&gt;
&lt;li&gt;不能使用arguments.caller&lt;/li&gt;
&lt;li&gt;禁止this指向全局对象&lt;/li&gt;
&lt;li&gt;不能使用fn.caller和fn.arguments获取函数调用的堆栈&lt;/li&gt;
&lt;li&gt;增加了保留字（比如protected、static和interface）&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>promise对象</title>
     <link href="http://beiyuu.com/promise"/>
     <updated>2015-10-13T00:00:00+08:00</updated>
     <id>http://beiyuu.com/promise</id>
     <content type="html">&lt;h3&gt;一、概述&lt;/h3&gt;

&lt;p&gt;在解释promise对象之前，先了解，js中异步的概念。
js语言的执行环境是&quot;单线程&quot;,也就是一次只能执行一个任务,如果任务多了,就需要排队,前面任务完成才能执行后面的任务.例如：&lt;/p&gt;

&lt;h4&gt;同步和异步：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;同步是一个任务完成执行下一个任务,每一个任务按照顺序来执行。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;异步是简而言之，任务执行顺序和排列的任务顺序不一致。假设有A和B两个任务，顺序是A&gt;B。A任务里面分为两段代码，一段是对外部的数据的请求，一段是一个回调函数。第一段执行完成不是立刻执行第二段代码，而是会到B任务等外部数据返回回来，再执行第二段代码。&lt;/p&gt;

&lt;p&gt;  var f1 = function(fn){
      console.log(&quot;1&quot;);
      setTimeout(fn, 1000);//向外部发送请求，fn就是回调函数。但是这里配置的是一秒后再执行。
  }
  var f2 = function(){
      console.log(&quot;2&quot;)
  }
  //再执行f2函数一秒之前，f3会执行。
  var f3 = function(){
      console.log(&quot;3&quot;);
  }
  f1(f2)
  f3();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;打印出来的结果是1&gt;3&gt;2，这里任务排列是f1&gt;f2&gt;f3但是真正执行的时候顺序改变了,这就是&quot;异步模式&quot;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;上面回调模式是建立在f2执行时间比较长，有可能会影响f3执行，不过这种模式缺点比较明显，不容易阅读，回调函数的名称必须写多了，作用是什么可能不是很清楚，而且每一种任务，只能有一个回调函数。&lt;/p&gt;

&lt;h4&gt;异步的流程控制&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var async = function (arg,callback){
    console.log(&quot;参数为&quot;+arg+&quot;一秒后返回&quot;);
    setTimeout(function(){callback(arg+1);}, 1000);
}

var final = function (value) {
    console.log(&#39;完成: &#39;, value);
}
async(1,function(value){
    async(value,final)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;首先第一次执行async代码，执行里面的内容。&lt;/li&gt;
&lt;li&gt;一秒钟后再执行callback函数，这里callback函数就是执行async，第二遍执行，里面内容，并且取函数的第一个参数值+1.&lt;/li&gt;
&lt;li&gt;第二遍执行async里面的函数的callback函数，这里函数就是final&lt;/li&gt;
&lt;li&gt;&lt;p&gt;final函数的会取value为参数。
这里会在执行完两遍async函数后再执行final，也就是两秒之后，这只是一层的嵌套，如果多几层嵌套，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  async(1, function(value){
      async(value, function(value){
          async(value, function(value){
              async(value, function(value){
                  async(value, function(value){
                  async(value, final);
                  });
              });
          });
      });
  });
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;串行执行&lt;/h3&gt;

&lt;p&gt;串行执行可以是一个任务完成再来执行另外一个任务，可以用来控制异步任务。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var items = [ 1, 2, 3, 4, 5, 6 ];
var results = [];
function series(item) {
  if(item) {
    async( item, function(result) {//这里的result也是item+1的值
      results.push(result);
      return arguments.callee(items.shift());
      //返回并且再次执行自身一遍。
    });
  } else {
    return final(results);
    //如果数组中没有项目，则执行final
  }
}

series(items.shift());
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;并行执行&lt;/h3&gt;

&lt;p&gt;也就是一同把所有的函数执行完成，再执行final，这个在效率上面有提升，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;items.forEach(function(item){
    async(item,function(reulse){
        results.push(reulse);
        if(results.length == items.length){
            final(reulses)
        }
    })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方式和前面串行方式不同的是，不需要等待前面一个执行完成执行后面那个任务，可以同时进行，但是这个也有一个弊端就是当同时进行的任务过多，给机器带来的性能压力就会体现出来。需要有一种结合这两种方式的更好的方法出来&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function launcher(){
    while(running &amp;lt; limit &amp;amp;&amp;amp; items.length &amp;gt; 0){
        var item = items.shift();
        async(item,function(result){
            results.push(result);
            running--;
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二、 Promise&lt;/p&gt;

&lt;h3&gt;概述&lt;/h3&gt;
</content>
   </entry>
   
   <entry>
     <title>装饰性模式</title>
     <link href="http://beiyuu.com/%E8%A3%85%E9%A5%B0%E6%80%A7%E6%A8%A1%E5%BC%8F"/>
     <updated>2015-09-10T00:00:00+08:00</updated>
     <id>http://beiyuu.com/装饰性模式</id>
     <content type="html">&lt;h2&gt;一、理解&lt;/h2&gt;

&lt;p&gt;在不改变原有的函数的基础上，添加新功能。也可以有继承的方式添加新的功能，但是那样会有一个子类和超类，子类依赖与超类。
有时候不想去改变原有的功能，就需要用到这种装饰者模式。
一个简单实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = function(){
    consol.log(&quot;a&quot;);
}
//为了不影响a函数，而又要在a函数基础上添加新的功能，可以如此：

var _a = a;
var a = function(){
    _a();
    console.log(&quot;aa&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里重写了一下a函数，让它加上新的功能，又对原来的函数没有改动。但是这种方式感觉还是不够好，一个函数名称没有改变，对于代码维护来说不知道那个是后来a那个是前面a。
还有一个_a需要去维护，万一添加的功能多了，或者a里面其实还有功能添加，这个时候维护起来就是一个噩梦了。
三是有一个this劫持的问题。如果a函数中用到this，那么在新的函数中this指向可能就会有问题，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//保存方法
var _getId = document.getElementById;

document.getElementById = function(id){
//添加新功能
    console.log(&quot;新功能&quot;);
//执行原来保存的方法
    return _getId(id); //报错：Illegal invocation    
}
var btn = document.getElementById(&quot;btn&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为该方法的执行环境必须是在document下面，这里重新覆盖的，this已经不是document而是window所以报错。可以改成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document.getElementById = function(id){
    console.log(&quot;新功能&quot;);
    return _getId.apply(document,arguments);    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二、用AOP装饰&lt;/p&gt;

&lt;p&gt;通过高阶函数，可以实现一些更加松散的方法，也更友好。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Function.prototype.after = function(fn){
    var _self = this;//保存原来的函数
    return function(){
        var ret = _self.apply(this,arguments);
        fn.apply(this,arguments);
        return ret;
    }
}

Function.prototype.before = function(fn){
    var _self = this;
    return function(){
        fn.apply(this,arguments);
        return _self.apply(this,arguments);
    }       
}

var a = function(){
    console.log(&quot;a&quot;);
}

var b = function(){
    console.log(&quot;b&quot;);
}

var _a = a.after(b);    
_a(); // ab

var _b = a.before(b);
_b(); //ba
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面两个方法，对于函数来说更加友好，不会去改变原有函数名称，并且动态的去添加新的功能。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>15年08月19日－周工作记录</title>
     <link href="http://beiyuu.com/%E5%91%A8%E7%BA%AA%E5%BD%95"/>
     <updated>2015-08-19T00:00:00+08:00</updated>
     <id>http://beiyuu.com/周纪录</id>
     <content type="html">&lt;p&gt;2015年08月19日&lt;/p&gt;

&lt;p&gt;本周工作学习心得：&lt;/p&gt;

&lt;h3&gt;一、垂直居中对齐&lt;/h3&gt;

&lt;p&gt;需求：在弹出框中对内容进行垂直居中定位&lt;/p&gt;

&lt;p&gt;状况：内容高度不定，&lt;/p&gt;

&lt;p&gt;解决方法：&lt;/p&gt;

&lt;p&gt;1、原来的解决方案，算出内容高度，然后用绝对定位，加上负边距实现&lt;/p&gt;

&lt;p&gt;2、现有移动端的实现方式更加简单&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.box{display:flex; display:-webkit-flex;}
.item{align-self:center;-webkit-align-self:center;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是要兼容更加低端的手机还需要用box这个老属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.box{
    display:box; display:-webkit-box;
    box-align:center; -webkit-box-align:center;
    display:flex; display:-webkit-flex;

}
.item{align-self:center;-webkit-align-self:center;}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;经常会遇到flex一些老浏览器和手机不支持情况，这个时候可以用box这个老的属性，兼容实现。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3&gt;二、数字自动转译&lt;/h3&gt;

&lt;p&gt;需求：在手机端点击输入框出来数字键盘&lt;/p&gt;

&lt;p&gt;问题：当输入到一定数字时候，数字自动转译&lt;/p&gt;

&lt;p&gt;解决方案：把number类型改成tel类型。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;该方案对于一些原生的placeholer支持也有作用，一些number对于placeholer支持不太好&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3&gt;三、angularJS 过滤&lt;/h3&gt;

&lt;p&gt;定义过滤器：对字符进行重新转换的过程。
自定义和使用过滤&lt;/p&gt;

&lt;p&gt;使用过滤服务：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.233 // 1.23保留两位小数点
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自定义服务：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myAppMoudel = angular.module(&quot;myApp&quot;,[]);
myAppMoudel.filter(&quot;addNum&quot;,function(){
    return function(item){
    //这里item指需要转换的字符
        return item+1;
    }
})

2 // 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;四、angularJS 服务&lt;/h3&gt;

&lt;p&gt;模版：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;body ng-app=&quot;myApp&quot;&amp;gt;
    &amp;lt;div ng-controller=&quot;test&quot;&amp;gt;
        &amp;lt;input type=&quot;button&quot; ng-click=&quot;show()&quot; value=&quot;点击&quot; /&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建立自定义服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myAppModule = angular.module(&quot;myApp&quot;,[]);
myAppModule.factory(&quot;myService&quot;,function(){
    return {
        fn:function(){
            console.log(&quot;self&quot;);
        }
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引用服务：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;自定义的服务一定是放在左右服务最后面。&lt;/p&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;myAppModule.controller(&quot;test&quot;,[&quot;$scope&quot;,&quot;myService&quot;,function($scope,myService){

$scope.show =function(){
    myService.fn();
}

}])
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>jekyll基本使用方式</title>
     <link href="http://beiyuu.com/jekyll%E4%BD%BF%E7%94%A8"/>
     <updated>2015-06-25T00:00:00+08:00</updated>
     <id>http://beiyuu.com/jekyll使用</id>
     <content type="html">&lt;h2&gt;基本使用方式&lt;/h2&gt;

&lt;p&gt;安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem install jekyll
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入文件夹&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jekyll new my-site
cd my-site
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jekyll serve

服务地址：http://localhost:4000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建立&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jekyll build

jekyll build -watch //持续跟踪
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文章要求&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: post
title: jekyll基本使用方式
description: jekyll基本使用方式
category: blog
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
</content>
   </entry>
   
   <entry>
     <title>原型理解</title>
     <link href="http://beiyuu.com/%E5%8E%9F%E5%9E%8B%E7%90%86%E8%A7%A3"/>
     <updated>2014-12-17T00:00:00+08:00</updated>
     <id>http://beiyuu.com/原型理解</id>
     <content type="html">&lt;h1&gt;原型解析&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;什么是原型?&lt;/li&gt;
&lt;li&gt;原型的作用是什么？&lt;/li&gt;
&lt;li&gt;堆和栈的区别？&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;1.对象分类&lt;/h2&gt;

&lt;p&gt;在js中有一个概念就是一切皆是对象，但是对象也有分不同的类型
先抛出几个问题在这篇文章中去解答：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;普通对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; var o = new Object();
 var o1 = {};
 var ff=function(){}; var o2=new ff();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; var f=function(){};
 var f1=Function(&quot;sopit&quot;,&quot;alert(&#39;a&#39;)&quot;);
 function f2(){}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原型对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; //源码

 function myFun(){
     var name=&quot;juzi&quot;;
 }

 function myFunPro(){
     this.name=&quot;juzi&quot;;
     this.t=function(){
         return &quot;tt&quot;;
     }
 }

 myFunPro.prototype.title=function(){
     return &quot;biaoti&quot;;
 }

 var m=new myFun();

 myFun.prototype=m;

 var u=i=m;

 var mP=new myFunPro();

 var o=new Object();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;blockquote&gt;&lt;p&gt;顺便说几个方法&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;tpyeof 可以知道数据类型，number,object,function,undefinded,boolean,string
 判断变量是否存在，使用typeof，例如：&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    if(a){alert(&quot;a&quot;);} //有抱错信息
    if(typeof !=&quot;undefined&quot;){ alert(&quot;a&quot;); } //不会报错
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;instanceof 可以判断是否是实例，例如： a instanceof A；输出的事一个布尔值&lt;/li&gt;
&lt;/ol&gt;


&lt;blockquote&gt;&lt;/blockquote&gt;

&lt;p&gt;我想到这里可以说一下原型有什么作用了：
1. 用来继承减少空间占用&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>AngularJS应用－基础概念</title>
     <link href="http://beiyuu.com/AngularJS%E5%AE%9E%E6%88%98-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"/>
     <updated>2014-09-23T00:00:00+08:00</updated>
     <id>http://beiyuu.com/AngularJS实战－基础概念</id>
     <content type="html">&lt;h2&gt;一、MVC 框架&lt;/h2&gt;

&lt;p&gt;所有实例基本框架：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;body ng-app=&quot;MyModule&quot;&amp;gt;
    // content...
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;二、基本概念&lt;/h2&gt;
</content>
   </entry>
   
   <entry>
     <title>AngularJS应用－指令</title>
     <link href="http://beiyuu.com/AngularJS-%E6%8C%87%E4%BB%A4"/>
     <updated>2014-09-23T00:00:00+08:00</updated>
     <id>http://beiyuu.com/AngularJS-指令</id>
     <content type="html">&lt;h2&gt;一、基本概念&lt;/h2&gt;

&lt;p&gt;说明概念：附加在HTML元素上面自定义标记，可以是：标签、属性、class类，通过AngularJS的HTML编辑器（$compile），在指定元素上面附加指定的行为，可以操作DOM，改变DOM元素，甚至它子节点。&lt;/p&gt;

&lt;p&gt;一般都是用ng开始，表示指令。
部分内置指令：ngBind,ngModle,ngView,ngClick等。
指令匹配形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 推荐使用方式
&amp;lt;span ng-bing=&quot;name&quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;span ng:bind=&quot;name&quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;span ng_bind=&quot;name&quot;&amp;gt;&amp;lt;/span&amp;gt;
// 符合HTML验证，（data）
&amp;lt;span data-ng-bind=&quot;name&quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;span x-ng-bing=&quot;name&quot;&amp;gt;&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;二、应用&lt;/h2&gt;

&lt;h3&gt;2.1 注册指令：&lt;/h3&gt;

&lt;p&gt;基本方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.directive(&quot;dir&quot;,function(){
    return {

    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般返回一个匿名的对象&lt;/p&gt;

&lt;p&gt;替换内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;&quot; ng-controller=&quot;de&quot;&amp;gt;
    &amp;lt;hello&amp;gt;&amp;lt;/hello&amp;gt;
&amp;lt;/div&amp;gt;

//定义了一个hello指令
var MyModule = angular.module(&quot;MyModule&quot;,[]);
MyModule.directive(&quot;hello&quot;,function(){
    return {
        restrict : &quot;E&quot;,
        template : &quot;&amp;lt;div&amp;gt;替换了&amp;lt;/div&amp;gt;&quot;,
        replace : true
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;restrict 可以是四个值：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;E：表示元素标签，&lt;hello&gt;&lt;/hello&gt;&lt;/li&gt;
&lt;li&gt;A：表示属性(默认属性), &lt;div hello&gt;&lt;/hello&gt;&lt;/li&gt;
&lt;li&gt;M：表示注释, &lt;!-- directive: hello --&gt;&lt;/li&gt;
&lt;li&gt;C：表示样式（class）,&lt;div class=&quot;hello&quot; &gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;遇到一个问题，样式（C）时，使用在input输入框，不能用“－”并且在指令名称中不能用大写，如果标签中是大写，那么在注册的时候需要改成小写。
但是不能input框，可以注册用大写。没有找到规律&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3&gt;2.2 保留原有内容，并且增加内容：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;MyModule.directive(&quot;hello&quot;,function(){
    return {
        restrict : &quot;E&quot;,
        transclude : true,
        template : &quot;&amp;lt;div&amp;gt;添加内容&amp;lt;div ng-transclude&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&quot;
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2.3 引用html模版&lt;/h3&gt;

&lt;p&gt;当有大量的html需要修改或者替换的时候可用，引用html模版文件，这样减少在js中写大量到html代码，并且还需要考虑拼接：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MyModule.directive(&quot;hello&quot;,function(){
    return {
        restrict : &quot;E&quot;,
        templateUrl : &quot;hello.html&quot;,
        replace : true
    }
})
&amp;lt;-- hello.html --&amp;gt;
&amp;lt;div&amp;gt;替换内容&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;这里可以考虑一些常用的html模块，直接用这种方式，给一个指令直接就把需要的html结构给出来，但是这里还牵涉到一个css，和这个模块要用到的js。参考fis&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;缓存模版，当有一些模版会重复使用到到的时候可以使用缓存模版方式，主要是牵涉到几个方法，put、get&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//注射器加载完所有模块时，此方法执行一次，run。
MyModule.run(function($templateCache){

    //put设置缓存模版，第一参数定义名称，第二个是内容。
    $templateCache.put(&quot;h&quot;,&quot;&amp;lt;div&amp;gt;缓存内容&amp;lt;/div&amp;gt;&quot;);

})

//获取缓存的内容
MyModule.directive(&quot;hello&quot;,function(){
    return {
        restrict : &quot;E&quot;,
        replace : true,
        template : $templateCache.get(&quot;h&quot;)
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2.4 LINk方法：&lt;/h3&gt;

&lt;p&gt;参数有四个分别是scope,element,attr,ctrl&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 指令 link使用 --&amp;gt;
&amp;lt;!-- 定义controller --&amp;gt;
&amp;lt;div class=&quot;&quot; ng-controller=&quot;myLoad&quot;&amp;gt;
    &amp;lt;load class=&quot;btn-deep-blue mt-vbig&quot;&amp;gt;测试加载&amp;lt;/load&amp;gt;
    &amp;lt;div id=&quot;show&quot;&amp;gt;显示&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义contraoller里面的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myLoadModule = angular.module(&quot;MyModule&quot;,[]);
myLoadModule.controller(&quot;myLoad&quot;,[&quot;$scope&quot;,function($scope){

    $scope.loadData = function(){
        angular.element(document.querySelector(&quot;#show&quot;)).addClass(&quot;btn-deep-blue&quot;);
        console.log(&quot;加载。。&quot;);
    }

}]);

//定义指令
    myLoadModule.directive(&quot;load&quot;,function(){
    return {
        restrict:&quot;E&quot;,
        link : function(scope,element,attr){
                element.bind(&quot;click&quot;,function(){
//这里的scope相当于和控制器中的$scope相连接了，能够获取到控制中的方法，通过$scope中转站衔接
                    scope.loadData();
                    // 作用相同:
                    // scope.$apply(&quot;loadData()&quot;)
                })

        }
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2.5 指令复用&lt;/h3&gt;

&lt;p&gt;通过link中的attr属性去复用指令&lt;/p&gt;

&lt;p&gt;HTML:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;&quot; ng-controller=&quot;myLoad1&quot;&amp;gt;
    &amp;lt;loading class=&quot;btn-deep-blue mt-vbig&quot; loadfn=&quot;loadData()&quot;&amp;gt;测试加载&amp;lt;/loading&amp;gt;
&amp;lt;/div&amp;gt;  
&amp;lt;div class=&quot;&quot; ng-controller=&quot;myLoad2&quot;&amp;gt;
    &amp;lt;loading class=&quot;btn-deep-blue mt-vbig&quot; loadfn=&quot;loadData2()&quot;&amp;gt;测试加载2&amp;lt;/loading&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JS:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 控制器定义
var MyModule = angular.module(&quot;MyModule&quot;,[]);
MyModule.controller(&quot;myLoad1&quot;,[&quot;$scope&quot;,function($scope){
    $scope.loadData = function(){
        console.log(&quot;加载。。1&quot;);
    }
}]);

MyModule.controller(&quot;myLoad2&quot;,[&quot;$scope&quot;,function($scope){
    $scope.loadData2 = function(){
        console.log(&quot;加载。。2&quot;);
    }
}]);

// 指令定义
myLoadModule.directive(&quot;load&quot;,function(){
    return {
        restrict:&quot;E&quot;,
        link : function(scope,element,attr){
                element.bind(&quot;click&quot;,function(){
                    scope.$apply(attr.loadfn)
        // 这里loadfn注意要小写
                })

        }
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2.6 指令间的调用&lt;/h3&gt;

&lt;p&gt;这里说一下另外一个方法：controller&lt;/p&gt;

&lt;p&gt;HTML:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
    &amp;lt;superman strength&amp;gt;力量&amp;lt;/superman&amp;gt;
    &amp;lt;superman strength speed&amp;gt;力量、速度&amp;lt;/superman&amp;gt;
    &amp;lt;superman strength speed light&amp;gt;力量、速度、光&amp;lt;/superman&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的controller是指令内部的，是暴露一些方法给外部调用:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 指令间调用
MyModule.directive(&quot;superman&quot;,function(){
    return {
        //独立作用域
        scope:{},
        restrict: &quot;AE&quot;,
        controller: function($scope){
            $scope.abilities=[];
            // 这里的this指的是？这里看是调用这个controller方法的对象，通过下面的调用知道，这是指令对象
            this.addStrength=function(){
                $scope.abilities.push(&quot;strength&quot;);
            }
            this.addSpeed=function(){
                $scope.abilities.push(&quot;speed&quot;);
            }
            this.addLight=function(){
                $scope.abilities.push(&quot;light&quot;);
            }
        },
        link : function(scope,element,attr){
            element.addClass(&quot;btn-deep-blue mt-tiny&quot;);
            element.bind(&quot;click&quot;,function(){
                console.log(scope.abilities);
            })
        }
    }
});

MyModule.directive(&quot;strength&quot;,function(){
    return {
        //require 引用了一个指令对象
        require: &quot;^superman&quot;,
        // link最后一个参数是传入 require引用的对象
        link: function(scope,element,attr,s){
            s.addStrength();
        }
    }
});
MyModule.directive(&quot;speed&quot;,function(){
    return {
        require: &quot;^superman&quot;,
        link: function(scope,element,attr,supermanCtrl){
            supermanCtrl.addSpeed();
        }
    }
});
MyModule.directive(&quot;light&quot;,function(){
    return {
        require: &quot;^superman&quot;,
        link: function(scope,element,attr,supermanCtrl){
            supermanCtrl.addLight();
        }
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;什么时候用controller什么时候用link，link指指令内部，做一个绑定事件，或者一些事件的处理，而controller是给外部调用&lt;/p&gt;&lt;/blockquote&gt;
</content>
   </entry>
   
   <entry>
     <title>学习笔记－设计模式 －函数</title>
     <link href="http://beiyuu.com/Javascript%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0"/>
     <updated>2014-09-20T00:00:00+08:00</updated>
     <id>http://beiyuu.com/Javascript模式学习-函数</id>
     <content type="html">&lt;h2&gt;第四章 函数&lt;/h2&gt;

&lt;h3&gt;4.1 背景&lt;/h3&gt;

&lt;p&gt;函数是js中使用率最高的一个对象，万物皆对象。函数也不例外，只是这个对象和别的对象来说有几个特别的特性，“执行”是其中一个。&lt;/p&gt;

&lt;p&gt;另外两个特性包括：是一个一等对象，提供作用域的支持。&lt;/p&gt;

&lt;p&gt;js本身有两种作用域，一种是全局的作用域，比如window，还有一个就是局部作用域，比如函数内用var声明的作用域，函数内用if或者for等内部声明的作用域还是属于函数内部的作用域，不属于if内部的作用域。&lt;/p&gt;

&lt;p&gt;函数既然也是对象，那么就会一样会有对象的一些特性，比如有 &lt;strong&gt;属性&lt;/strong&gt; 和 &lt;strong&gt;方法&lt;/strong&gt;。&lt;/p&gt;

&lt;h4&gt;函数的中的匿名函数和命名函数之间的区别：&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;../../images/fnName.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;匿名函数的name属性值是一个空字符串，命名函数的name值是有值的。这是他们唯一的区别。
真正有三种术语方面的说法：带有命名的函数表达式、无名字的函数表达式、函数声明&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var add = function add(){}; //带有命名的函数表达式,末尾必须要有分号

var add = function (){};  //无名字的函数表达式

function add(){}; //函数声明，末尾可以不用分号
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;“函数直接量”这个概念一般用来表示函数表达式或者匿名函数表达式，尽量不要用，有歧义。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3&gt;4.2 函数提前&lt;/h3&gt;

&lt;p&gt;前面有过叫做变量提前的说法，也就是在运行环境中，变量始终会方便开始，即使是后面定义的也是如此。函数也有提前这一说法，因为函数也是一种对象，赋值给了变量。&lt;/p&gt;

&lt;p&gt;“函数声明”定义的函数不仅能够让函数&lt;strong&gt;定义&lt;/strong&gt;提前，还能够让声明提前。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo(){console.log(&quot;foo&quot;)}
function bar(){console.log(&quot;bar&quot;)}

function next(){

    //next 内部的foo和bar会覆盖全局的foo和bar

    console.log(typeof foo);  //function 因为foo是一个函数声明
    console.log(typeof bar);  //undefined  bar是一个无名的函数表达式

    foo();  // new foo
    bar();  //typeError: bar is not a function 

    function foo(){
        console.log(&quot;new foo&quot;)
    }
    var bar = function(){
        console.log(&quot;new bar&quot;)          
    };
    console.log(typeof bar);  //function 

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;4.3 回调模式&lt;/h3&gt;

&lt;p&gt;该模式应该是函数经常用到的一个方式，因为函数是对象，也就是说函数可以作为参数传递给另外一个函数，当给函数传入一个函数参数，并且在函数内调用了函数参数，并执行，称传入参数的函数叫回调函数，也成回调。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function f(callback){
    callback();//执行了
}       

function cb(){
    console.log(&quot;回调&quot;);
}   

f(cb);// 回调
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;遍历节点并做一定动作，一般逻辑，把节点抛出来，并用方法隐藏，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//findNodes 方法找到节点并返回出来，
 var findNodes = function(){
    var nodeParent = document.getElementById(&quot;J_ul&quot;);
    var nodes = nodeParent.getElementsByTagName(&quot;li&quot;);
    return nodes;
 }

 //隐藏节点
var hide = function(node){
    var i=0, max = node.length; //遍历节点
    for(; i &amp;lt; max; i++){
     node[i].style.display = &quot;none&quot;;
    }
}

//显示节点
var show = function(node){
    var i=0, max = node.length; //遍历节点
    for(; i &amp;lt; max; i++){
        node[i].style.display = &quot;block&quot;;
    }
}

//执行
hide(findNodes());
show(findNodes());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里做一次操作就会遍历节点一遍，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var findNodes = function(callback){
 var nodeParent = document.getElementById(&quot;J_ul&quot;);
 var nodes = nodeParent.getElementsByTagName(&quot;li&quot;);
 var length = nodes.length;

 //判断参数callback是不是函数
 if(typeof callback !== &quot;function&quot;){
  callback = false;
 }

 while(length){
  length--;
  if(callback){
    callback(nodes[length]);// 这是回调函数可以操作部分
  }
 }

 return nodes; //还是可以返回节点
 }
 var hide = function(node){
  node.style.display = &quot;none&quot;;
  }
  var show = function(node){
  node.style.display = &quot;block&quot;;
  }

  findNodes(hide);
  findNodes(show);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 这里hide方法和show方法已经不需要再去遍历一回节点，相当于操作和需要操作的数据分离，其实有点像数据和控制器分离，这样做到findNodes方法更加&lt;code&gt;通用&lt;/code&gt;。&lt;/p&gt;

&lt;h3&gt;4.4 返回函数&lt;/h3&gt;

&lt;blockquote&gt;&lt;p&gt;函数是一个特殊变量，当有()的时候就是表示执行。执行完成之后就看有没有return，有的话就是这个函数返回出来的东西。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;函数里面还可以返回函数，但是这首先是函数执行之后的返回，也就是必须()，如果只是变量之间转换，例如：var a=fn;这样a是没有得到fn的返回值。这个只是a引用了fn。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var fn=function(){
    console.log(1);
    retunr function(){
     console.log(2);
    }
}
var a=fn;
var b=fn();
console.log(typeof a); // function,这个时候a只是fn的引用。
console.log(typeof b); // function，这个时候b是fn()执行完成之后的返回出来的function
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 如果fn执行完成之后没有返回值，即使赋值到变量上，变量也是undefind;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var fn = function(){
        console.log(1)      
    }   
    var a = fn;
    var b = fn();
    console.log(typeof a); // function,这个时候a只是fn的引用。
    console.log(typeof b); // undefined，因为fn()执行完成之后没有返回值，所以b得到对结果就是undefined;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数内部有一些私有的数据，在函数外部是访问不到，但是函数内部的函数是可以访问到，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var fn = function(){
    var count = 0; //该变量在fn外部访问不到，因为做用域的原因。
    return function(){
        count += 1; //这里可以访问到count，在函数内部。
    }
}
var a =fn();//这里执行过一次fn(),也就是初始化了一下count。
a(); //当第一次执行a()时，count已经初始化一次，因为a函数是fn里面的，所以能够访问到count变量。这个时候执行返回出来的函数。这里执行了也就是＋1。
a(); //2
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;这里有一个疑惑为什么第二次执行的时候不是1，而是2？&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;这里需要解释保存count为1的在哪里，这里就相当于开始的count=0,这是最开始的，也是执行一次就改变一次。这里可以理解count是相对返回的函数来说是一个全局变量。
例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var count = 0;
var add = function(){
    count += 1;
}
add();//这里每执行一次就改变全局变量count一次，只是前面那个例子是包含在一个函数内部。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;4.5 自定义函数&lt;/h3&gt;

&lt;p&gt;覆盖自己的函数定义，可以初始化操作一次。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var selfFn = function(){
        console.log(&quot;first&quot;);
        selfFn = funcition(){
            console.log(&quot;two&quot;);
        }
    }
    selfFn(); // first
    selfFn(); //two
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里是第一次执行的时候正常流程，并且把函数重新赋值到函数的名称，当第二次执行的时候，这个时候实际上，函数执行的内容已经覆盖开始到执行内容。函数被重定义。
函数是一个执行体，变量只是这个函数执行的引用。如果这个函数赋值给另外一个变量会怎样？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var otherFn = selfFn;
    otherFn();
    otherFn();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;4.6 自执行函数&lt;/h3&gt;

&lt;p&gt;一般这种函数是有一些只是执行一次，后面再也不执行了，并且可以保证在它里面的变量不会污染整个全局变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (function(){
        var who = &quot;juzipi&quot;;
        console.log(who);
    })() //这里括号完成表示执行

    //另外一种方式
    (function(){
    //do something
    }())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以给自执行函数加上参数，如果参数是window这样如果在浏览器的环境可以访问到全局的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var who = &#39;juzipi&#39;;
    (function(w){
        console.log(w.who); //juzipi
    })(window)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;为了通用型最好是不要用window作为参数，因为这个职能在浏览器的环境下执行&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4&gt;立即执行函数返回值&lt;/h4&gt;

&lt;p&gt;立即执行的函数也是可以返回值的，和他们函数一样。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var val = (function(){
        return 2+2;
    })()

    //可以省略括号

    var val = function(){
        return 2+2;
    }()

    //属性定义
    var obj ={
        m : (function(){
            var who = &quot;me&quot;;
            var what = &quot;call&quot;;
            return who +&quot;&quot;+what;
        })(),
        getM : function(){
            return this.m;
        }
    }

    obj.m;  //me call
    obj.getM();  //me call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里m这个属性值实际上是一个字符串，而getM是一个方法，所以要执行后得到结果。&lt;/p&gt;

&lt;h2&gt;立即初始化对象&lt;/h2&gt;

&lt;p&gt;建立一个对象，并且运行对象方法，对象字面量方式建立对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ({
        max : 2,
        min :1,
        add :function(){
            return max + min;
        },
        init : function(){
            return console.log(this.add());
        }
    }).init()
    //两种方式调用
    ({}).init();
    ({}.init());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实就是建立对象直接执行方法，如果初始化工作比较复杂，建议用这种方式，这种方式，结构比较清楚，是一次性初始化。
但是这种方式在js压缩工作工具里面不是很友好。&lt;/p&gt;

&lt;h2&gt;条件初始化&lt;/h2&gt;

&lt;p&gt;当知道某种条件在整个程序生命周期不会发生改变，这样就是对这个条件进行一次初始化操作就好，使用最多的就是浏览器特性检测。一般来说浏览器对于某种特性的支持都是固定的，不会存在变化的可能。比如对于事件的添加删除。
原来我们经常会这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var U = {
        addFn : function(el,type,fn){
            if(typeof window.addEventListener == &quot;function&quot;){
                el.addEventListener(type,fn,false);
            }else if(typeof document.attachEvent == &quot;function&quot;){
                el.attchEvnet(&quot;on&quot;+type, fn);
            }else{
                el[&quot;on&quot;+type] = fn;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这样效率不高，因为每次执行U.addFn()的时候都会去查一遍浏览器的特性，因为这个特性是固定的，所以不需要每一次都去查询一遍，只需要查询一次就可以。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var U = {
    addFn : null
    }

if(typeof window.addEventListener == &quot;function&quot;){
    U.addFn = functon(el,type,fn){
        el.addEventListener(type,fn,false);
    }esle if(typeof doucment.attachEvent == &quot;function&quot;){
    U.addFn = function(el,type,fn){
        el.attchEvent(&quot;on&quot;+type,fn)
    }else{
    U.addFn = function(el,type,fn){
        el[&quot;on&quot;+type] = fn; //这里说明一下，为什么用中括号形式，而是“.”形式，因为后面那种形式不能使用字符串相加的运算
        }
    }   
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>学习笔记－设计模式－基础</title>
     <link href="http://beiyuu.com/Javascript%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0"/>
     <updated>2014-09-18T00:00:00+08:00</updated>
     <id>http://beiyuu.com/Javascript模式学习</id>
     <content type="html">&lt;h1&gt;Javascript模式学习&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2&gt;变量&lt;/h2&gt;

&lt;h3&gt;1、全局变量&lt;/h3&gt;

&lt;p&gt;都知道不能随便取全局变量，在浏览器中存在一个默认的一个全局对象this，还有一个全局的属性window，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var n = 2；
this.n; //2
this.window.n; //2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想要改变全局对象名称也可以随便在任何函数里面都可以&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; var global=(function(){
    return this;
 }())
 //重新命名全局对象的名称未global;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2、函数内变量会前置&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var n=&quot;blue&quot;;
function varFront(){
    consloe.log(n); //undefined
    var n = &quot;red&quot;; 
    console.log(n); //red
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我认为的第一个会是&lt;code&gt;blue&lt;/code&gt;，但是却是&lt;code&gt;undefined&lt;/code&gt;，因为&lt;code&gt;javascript&lt;/code&gt;的引擎机制的原因，会先创建变量、函数、参数，这个阶段是一个预编译的阶段，会扫描整个上下文，再来代码运行阶段，运行里面的函数表达式。在这一段代码中因为后面创建的变量和前面的全局变量是同名的，根据刚才的原则先创建变量再运算。&lt;/p&gt;

&lt;p&gt;实际就变成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var n=&quot;blue&quot;;
function varFront(){
    var n; //提前到前面
    console.log(n);
    var n = &quot;red&quot;;
    console.log(n); //rend

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;循环&lt;/h2&gt;

&lt;h3&gt;1、for&lt;/h3&gt;

&lt;p&gt;循环也是常用的一种语法方式，在开发中避免对于DOM操作时候多次寻找耗费资源&lt;/p&gt;

&lt;p&gt;比如有一个ul下面的li集合&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for（var i = 0; i&amp;lt;li.length;i++ ）{
    //li[i];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里每一次的读取i都回去重新找一遍li，而操作DOM是非常耗资源的一个事情，应该改成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var length=li.length;
for (var i=0; i&amp;lt;length; i++){
    //li[i]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存为一个变量存起来，就读取一次减少资源消耗。
再简化一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var i,li=[];
for(i=li.length;i--){
    //li[i]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里减少一个变量，并且是减量循环，减量循环比增量循环速度更快，解释是：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;因为和零比较要比和非零数字或数组长度比较要高效的多&lt;/code&gt;?这个没有很明白；
再有就是while循环&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var li=[],i=li.length;
while(i--){
    //li[li];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2、for-in&lt;/h3&gt;

&lt;p&gt;这个用来循环对象里面的属性，这里需要了解对象属性有两种情况，一种是原生一种prototype原型立案链集成。通过方法hasOwnProperty()去过滤。
实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var man={hands:2,head:1,legs:2},i;
if(Object.prototype.clone==&quot;undefined&quot;){
    Object.prototype.clone=function(){};
}
for(i in man){
    if(man.hasOwnProperty(i)){ 
    //通过hasOwnProperyt判断clone是不是原有的属性，还是通过prototype加进来的。这里如果运行到clone，通过的值是false；
        console.log(i, &quot;:&quot;, man[i]);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;不扩充内置原型&lt;/h3&gt;

&lt;p&gt;可以扩充构造函数的prototype的原型，可以给object()，添加新的方法，但是这种方式尽量不要使用因为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不好控制，和你一起开发的人员不知道你加了这么一个原型在里面，会不会重新覆盖，&lt;/li&gt;
&lt;li&gt;一个有可能新的EC版本增加新的方法和现在的方法冲突，&lt;/li&gt;
&lt;li&gt;就像上面那个object遍历如果不加hasOwnProperty()判断会遍历出来，这个和预想的结果不一样，而加了这个需要和你合作的每个开发人员说明。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;也有情况是可以加上的，就是未来EC版本会加上这个方法，你可以预先把这个实现了，并且和团队其他人员沟通过后，给出文档。&lt;/p&gt;

&lt;h3&gt;switch&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var i=0,t=&#39;&#39;;
switch (i){
case 1:
    t=&#39;不显示&#39;;
    break;
case 0:
    t=&#39;显示&#39;;
    break;
defalut:
    t=&#39;默认显示&#39;        
}
//显示
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;代码格式规范&lt;/h2&gt;

&lt;p&gt;团队之间代码格式规范是一个团队合作的基础&lt;/p&gt;

&lt;h1&gt;3、直接量和构造函数&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;这一章原来一直都有接触，但是并没有真正理解里面的运行逻辑，通过这一章的了解需要了解里面的运行逻辑是什么。并且对于直接量和构造函数之间的区别有所收获。&lt;/p&gt;

&lt;h2&gt;3.1 对象创建的三种形式&lt;/h2&gt;

&lt;h4&gt;一种是直接量例如：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;    //这里创建了一个空对象
    var o={}；
    //也可以给这个对象直接加上方法和属性。
    var o={
        name:&quot;juzi&quot;,
        age:12,
        title:function(){
            return &quot;工程师&quot;；
        }  //这里说明一下‘,&#39;该符号，可以在现代浏览器中加上，但是在IE中会报错
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;第二种就是根据内置的Object对象创建一个实例&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var o=new Object();
//创建一个数字对象
var n=new Object(2);
console.log(n.constructor === Number); // true
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;第三种是自定义构造函数&lt;/h4&gt;

&lt;p&gt;要好理解这种方式，就是把p当做Object来对待，相当于实例了一个p对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var p=function(){
    this.age=12;
    this.name=&#39;juzi&#39;;
    this.title=function(){
        return &quot;工程师&quot;；
    }
}

var p_01=new p();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际创建的过程：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建一个空的对象｛｝；并且把它引用赋给this，继承函数原型&lt;/li&gt;
&lt;li&gt;添加属性和方法给this&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回this指向的新对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  var p = function(){
      //this={}
      this.age = 12;
      this.name = &quot;juzi&quot;;
      this.title = function(){
          return &quot;工程师&quot;
      }
      //return this;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;构造函数返回值&lt;/h4&gt;

&lt;p&gt;当用new调用一个构造函数的时候，其实调用的是这个构造函数里面的返回的对象，可以自定义返回的对象，如果没有定义的话，默认返回的事this这个对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var p ＝ function(){
        this.name=&quot;juzi&quot;;
        var that = {};
        that.name = &quot;juzipi&quot;;
        return that;
    }
    var me = new p();
    me.name;  // juzipi
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;如果返回的不是对象，是字符串，数字，布尔值，程序不会抱错，这个值会被忽略，最终还是返回this所指的对象。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4&gt;如果没有使用new&lt;/h4&gt;

&lt;p&gt;没有使用new的时候，函数内部的this实际上面指的是全局对象，如果是在浏览器里面指的就是window对象，这个并不是我们想要的效果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var p = function(){
        this.name = &quot;juzi&quot;;
    }
    var me = new p(); // suc
    var me = p();
    console.log(typeof me);  //undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以这就需要我们在用函数命名的时候，有一个约定，不然自己搞混了，函数开始字母用小写（myFunction），构造函数就用大写（MyFunction）。&lt;/p&gt;

&lt;h4&gt;使用that&lt;/h4&gt;

&lt;p&gt;为了避免忘记new等一些错误写法，可以全部返还that这个对象，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var p = function(){
        var that = {}
        that.name = &quot;juzi&quot;;
        return that;
    }
    var me = p();
    me.name; //juzi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候就不会发生错误，能够得到里面的值，但是这个有一个问题，不能继承方法的原型。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;这里的that可以是任何的字&lt;/p&gt;&lt;/blockquote&gt;
</content>
   </entry>
   
 
</feed>
