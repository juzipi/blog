<!DOCTYPE html>
<html>
<head>

    <meta charset="utf-8" />
    <title>学习笔记－设计模式－基础 | juzipi</title>
    <meta name="renderer" content="webkit">
    <meta name="description" content="Blog" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <link rel="stylesheet" href="/blog/css/default.css" type="text/css" />
    <link rel="icon" href="/blog/logo.png" type="image/png">
    <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/atom.xml" />
    <script src="/blog/js/jquery-1.7.1.min.js" type="text/javascript"></script>
</head>
<body>


    <link rel="stylesheet" href="/blog/js/prettify/prettify.css" />
<style type="text/css">
    body { background:#e8e8e8; }
    @media screen and (max-width: 750px){
        body { background:#fff; }
    }
    @media screen and (max-width: 1020px){
        body { background:#fff; }
    }
</style>

<div id="content">
    <div class="entry">
        <h1 class="entry-title"><a href="/blog/Javascript%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0" title="学习笔记－设计模式－基础">学习笔记－设计模式－基础</a></h1>
        <p class="entry-date">2014-09-18</p>
        <h1>Javascript模式学习</h1>

<hr />

<h2>变量</h2>

<h3>1、全局变量</h3>

<p>都知道不能随便取全局变量，在浏览器中存在一个默认的一个全局对象this，还有一个全局的属性window，</p>

<pre><code>var n = 2；
this.n; //2
this.window.n; //2
</code></pre>

<p>如果想要改变全局对象名称也可以随便在任何函数里面都可以</p>

<pre><code> var global=(function(){
    return this;
 }())
 //重新命名全局对象的名称未global;
</code></pre>

<h3>2、函数内变量会前置</h3>

<pre><code>var n="blue";
function varFront(){
    consloe.log(n); //undefined
    var n = "red"; 
    console.log(n); //red
}
</code></pre>

<p>这里我认为的第一个会是<code>blue</code>，但是却是<code>undefined</code>，因为<code>javascript</code>的引擎机制的原因，会先创建变量、函数、参数，这个阶段是一个预编译的阶段，会扫描整个上下文，再来代码运行阶段，运行里面的函数表达式。在这一段代码中因为后面创建的变量和前面的全局变量是同名的，根据刚才的原则先创建变量再运算。</p>

<p>实际就变成：</p>

<pre><code>var n="blue";
function varFront(){
    var n; //提前到前面
    console.log(n);
    var n = "red";
    console.log(n); //rend

}
</code></pre>

<h2>循环</h2>

<h3>1、for</h3>

<p>循环也是常用的一种语法方式，在开发中避免对于DOM操作时候多次寻找耗费资源</p>

<p>比如有一个ul下面的li集合</p>

<pre><code>for（var i = 0; i&lt;li.length;i++ ）{
    //li[i];
}
</code></pre>

<p>这里每一次的读取i都回去重新找一遍li，而操作DOM是非常耗资源的一个事情，应该改成：</p>

<pre><code>var length=li.length;
for (var i=0; i&lt;length; i++){
    //li[i]
}
</code></pre>

<p>保存为一个变量存起来，就读取一次减少资源消耗。
再简化一下：</p>

<pre><code>var i,li=[];
for(i=li.length;i--){
    //li[i]
}
</code></pre>

<p>这里减少一个变量，并且是减量循环，减量循环比增量循环速度更快，解释是：</p>

<p><code>因为和零比较要比和非零数字或数组长度比较要高效的多</code>?这个没有很明白；
再有就是while循环</p>

<pre><code>var li=[],i=li.length;
while(i--){
    //li[li];
}
</code></pre>

<h3>2、for-in</h3>

<p>这个用来循环对象里面的属性，这里需要了解对象属性有两种情况，一种是原生一种prototype原型立案链集成。通过方法hasOwnProperty()去过滤。
实例：</p>

<pre><code>var man={hands:2,head:1,legs:2},i;
if(Object.prototype.clone=="undefined"){
    Object.prototype.clone=function(){};
}
for(i in man){
    if(man.hasOwnProperty(i)){ 
    //通过hasOwnProperyt判断clone是不是原有的属性，还是通过prototype加进来的。这里如果运行到clone，通过的值是false；
        console.log(i, ":", man[i]);
    }
}
</code></pre>

<h3>不扩充内置原型</h3>

<p>可以扩充构造函数的prototype的原型，可以给object()，添加新的方法，但是这种方式尽量不要使用因为：</p>

<ul>
<li>不好控制，和你一起开发的人员不知道你加了这么一个原型在里面，会不会重新覆盖，</li>
<li>一个有可能新的EC版本增加新的方法和现在的方法冲突，</li>
<li>就像上面那个object遍历如果不加hasOwnProperty()判断会遍历出来，这个和预想的结果不一样，而加了这个需要和你合作的每个开发人员说明。</li>
</ul>


<p>也有情况是可以加上的，就是未来EC版本会加上这个方法，你可以预先把这个实现了，并且和团队其他人员沟通过后，给出文档。</p>

<h3>switch</h3>

<pre><code>var i=0,t='';
switch (i){
case 1:
    t='不显示';
    break;
case 0:
    t='显示';
    break;
defalut:
    t='默认显示'        
}
//显示
</code></pre>

<h2>代码格式规范</h2>

<p>团队之间代码格式规范是一个团队合作的基础</p>

<h1>3、直接量和构造函数</h1>

<hr />

<p>这一章原来一直都有接触，但是并没有真正理解里面的运行逻辑，通过这一章的了解需要了解里面的运行逻辑是什么。并且对于直接量和构造函数之间的区别有所收获。</p>

<h2>3.1 对象创建的三种形式</h2>

<h4>一种是直接量例如：</h4>

<pre><code>    //这里创建了一个空对象
    var o={}；
    //也可以给这个对象直接加上方法和属性。
    var o={
        name:"juzi",
        age:12,
        title:function(){
            return "工程师"；
        }  //这里说明一下‘,'该符号，可以在现代浏览器中加上，但是在IE中会报错
    }
</code></pre>

<h4>第二种就是根据内置的Object对象创建一个实例</h4>

<pre><code>var o=new Object();
//创建一个数字对象
var n=new Object(2);
console.log(n.constructor === Number); // true
</code></pre>

<h4>第三种是自定义构造函数</h4>

<p>要好理解这种方式，就是把p当做Object来对待，相当于实例了一个p对象。</p>

<pre><code>var p=function(){
    this.age=12;
    this.name='juzi';
    this.title=function(){
        return "工程师"；
    }
}

var p_01=new p();
</code></pre>

<p>实际创建的过程：</p>

<ul>
<li>创建一个空的对象｛｝；并且把它引用赋给this，继承函数原型</li>
<li>添加属性和方法给this</li>
<li><p>返回this指向的新对象</p>

<pre><code>  var p = function(){
      //this={}
      this.age = 12;
      this.name = "juzi";
      this.title = function(){
          return "工程师"
      }
      //return this;
  }
</code></pre></li>
</ul>


<h4>构造函数返回值</h4>

<p>当用new调用一个构造函数的时候，其实调用的是这个构造函数里面的返回的对象，可以自定义返回的对象，如果没有定义的话，默认返回的事this这个对象。</p>

<pre><code>    var p ＝ function(){
        this.name="juzi";
        var that = {};
        that.name = "juzipi";
        return that;
    }
    var me = new p();
    me.name;  // juzipi
</code></pre>

<blockquote><p>如果返回的不是对象，是字符串，数字，布尔值，程序不会抱错，这个值会被忽略，最终还是返回this所指的对象。</p></blockquote>

<h4>如果没有使用new</h4>

<p>没有使用new的时候，函数内部的this实际上面指的是全局对象，如果是在浏览器里面指的就是window对象，这个并不是我们想要的效果。</p>

<pre><code>    var p = function(){
        this.name = "juzi";
    }
    var me = new p(); // suc
    var me = p();
    console.log(typeof me);  //undefined
</code></pre>

<p>所以这就需要我们在用函数命名的时候，有一个约定，不然自己搞混了，函数开始字母用小写（myFunction），构造函数就用大写（MyFunction）。</p>

<h4>使用that</h4>

<p>为了避免忘记new等一些错误写法，可以全部返还that这个对象，例如：</p>

<pre><code>    var p = function(){
        var that = {}
        that.name = "juzi";
        return that;
    }
    var me = p();
    me.name; //juzi
</code></pre>

<p>这个时候就不会发生错误，能够得到里面的值，但是这个有一个问题，不能继承方法的原型。</p>

<blockquote><p>这里的that可以是任何的字</p></blockquote>


       
    </div>



    <div class="sidenav">
        <h2>Blog</h2>
        <ul class="artical-list">
        
            <li><a href="/blog/jekyll%E4%BD%BF%E7%94%A8">jekyll基本使用方式</a></li>
        
            <li><a href="/blog/Javascript%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0">学习笔记－设计模式 －函数</a></li>
        
            <li><a href="/blog/Javascript%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0">学习笔记－设计模式－基础</a></li>
        
            <li><a href="/blog/%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%80%83">模块化学习思考</a></li>
        
        </ul>

        <h2>Opinion</h2>
        <ul class="artical-list">
        
        </ul>

        <h2>Project</h2>
        <ul class="artical-list">
        
        </ul>
    </div>
</div>

<script src="/blog/js/post.js" type="text/javascript"></script>


    
</body>
</html>
