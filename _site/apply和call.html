<!DOCTYPE html>
<html>
<head>

    <meta charset="utf-8" />
    <title>apply和call应用 | juzipi</title>
    <meta name="renderer" content="webkit">
    <meta name="description" content="Blog" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <link rel="stylesheet" href="/blog/css/default.css" type="text/css" />
    <link rel="icon" href="/blog/logo.png" type="image/png">
    <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/atom.xml" />
    <script src="/blog/js/jquery-1.7.1.min.js" type="text/javascript"></script>
</head>
<body>


    <link rel="stylesheet" href="/blog/js/prettify/prettify.css" />
<style type="text/css">
    body { background:#e8e8e8; }
    @media screen and (max-width: 750px){
        body { background:#fff; }
    }
    @media screen and (max-width: 1020px){
        body { background:#fff; }
    }
</style>
<div class="head">
    <a href="/blog/">
        <img src="/blog/images/logo_24.png" alt="logo" class="logo" />
    </a>
</div>
<div id="content">
    
    <div class="entry">
        <h1 class="entry-title"><a href="/blog/apply%E5%92%8Ccall" title="apply和call应用">apply和call应用</a></h1>
        <p class="entry-date">2012-03-10</p>
        <h2>一、基本认识</h2>

<p>都是Function原型定义的两个方法，Function.prototype.apply和Function.prototype.call。也就是可以通过函数进行调用</p>

<pre><code>fn.apply(this,[arg1,arg2]);
fn.call(this,arg1,arg2);
</code></pre>

<p>两个方法作用相同，第一个参数传入的都是，该函数内 this 的指向。</p>

<p>从第二个参数开始，可以看到传入的参数不同。前面apply传入的是一个数组，call传入的参数依次传入函数。</p>

<blockquote><p>call是可以在确定传入什么参数的时候使用，而apply是可以在一些不确定的参数情况下面使用，比如可以针对这个数组做一些添加和删除的动作。</p>

<p>也就是apply传入的参数是可以变化的。</p></blockquote>

<p>如果第一个参数传入的是null，函数体内this会指向默认的宿主对象，如果在浏览器中就是 window。</p>

<pre><code>var fn = function(){
    console.log(this);
}
fn.apply(null); //true
</code></pre>

<p>如果是严格模式下面，this还是为null。</p>

<pre><code>var fn = function(){
    "use strict";
    console.log(this===window);
}
fn.apply(null); //false
</code></pre>

<h2>二、使用场景</h2>

<p>1、改变this指向。
改变的是需要执行函数的内部指向。</p>

<pre><code>var FnApply = function(par){
    this.name = "apply";//这里其实是覆盖了ObjectApply对象的name属所以下面的这一行打印是apply
    console.log(this.name);//apply  
    console.log(this.sex); // man 这里调用的就是ObjectApply对象的色系属性
    console.log(par) // me  这里调用的是传入进Arr数组的第一个参数
    this.name = "apply2";//如果在这里重新覆盖，是不会对console.log(this.name);这个起作用。
}
var ObjectApply = {
    name : "ObjectApply",
    sex:"man"
}
var Arr = ["me","you"]
FnApply.apply(ObjectApply,Arr); 
</code></pre>

<p>首先 FnApply.apply(ObjectApply,Arr);是执行了FnApply该函数，而把函数体内的 this指向的是ObjectApply这个对象。</p>

<p>修正this指向，在一些函数嵌套多一些的时候this指向经常，出现问题。</p>

<pre><code>document.getElementById("show").onclick=function(){
    console.log(this.id); //show
}
</code></pre>

<p>如果在其中加入一个函数</p>

<pre><code>document.getElementById("show").onclick=function(){
    var fn = function(){
        console.log(this.id); //undefined
    }
    fn();
}
</code></pre>

<p>这时候可以用apply或者是call来修正this指向。</p>

<pre><code>document.getElementById("show").onclick=function(){
    var fn = function(){
        console.log(this.id); //show
    }
    fn.call(this);
}
</code></pre>

<blockquote><p>当然在这里也可以前面把this缓存起来，放在一个变量里面。</p></blockquote>

<pre><code>document.getElementById("show").onclick=function(){
    var _self = this;
    var fn = function(){
        console.log(_self.id); //show
    }
    fn();
}
</code></pre>

<p>2、Function.prototype.bind
一般现在的浏览器都能很好的支持这个方法，该方法就是为函数内部指定this对象。如果没有实现该方法，模拟方法：</p>

<pre><code>Function.prototype.bind=function(context){
    var _self = this;
    return function(){
        return _self.apply(context,arguments);
    }
}
//分步骤解释一下该方法
//原始方式
document.getElementById("show").onclick=function(){
    var fn = function(){
        console.log(this.id); //show
    };
    fn.bind(this)();
// fn.bind(),这里的fn是一个函数对象，还没有执行，只是执行了对象上面的bind方法。
// 而bind方法返回的一个函数，也就是需要再一次执行。fn.bind()(),这个时候才是真正执行了bind之后返回的方法。
    fn(); //undefined,这里执行的是就是最开始的那段函数。

}
//直接把bind方法绑定在函数后面，这个时候赋给变量的fn就是执行bind完成之后返回的函数。

//也就是：function(){
//              return _self.apply(context,arguments);
//          }

document.getElementById("show").onclick=function(){
    var fn = function(){
        console.log(this.id); //show
    }.bind(this);
    fn();
    //这里执行的就是bind方法执行后返回的函数。
}

//也可以是这样：
document.getElementById("show").onclick=function(){
    var fn = function(){
        console.log(this.id); //show
    };
    var fnfn = fn.bind(this);
    //把返回函数赋予一个变量
    fnfn();
}
</code></pre>

<p>了解bind方法，需要了解的一点是，函数绑定该方法后，一定返回的是一个函数，需要再一次执行，实际上是执行了_self.apply(content,arguments);</p>

<p>高级bind方法实现：</p>

<pre><code>Function.prototype.bind = function(){
    var _self = this;
    var context = [].shift.call(arguments);
//取出第一个参数作为上下文替换
    var arg = [].slice.call(arguments);
//把其他参数转换成数组
    return function(){
        return _self.apply(context,[].concat.apply(arg,[].slice.call(arguments)));
//concat合并后面执行函数的参数和前面arg数组
    }
}

document.getElementById("show").onclick=function(){
    var fn = function(){
        console.log(this.id); //show
        console.log(arguments); //you,wo 
    }.bind(this,"you");
    fn("wo");
}
</code></pre>

<h2>三、借用其他方法</h2>

<h3>3.1 类数组借用</h3>

<p>一些类数组，但是不是真正的数组，不能使哟push方法，但是可以通过借用的方法，使得有数组的方法。例如arguments，它不是数组，但是通过借用可以实现数组的一些方法。</p>

<pre><code>[].shift.call(arguments); //取出最前面一项
[].slice.call(arguments); //转换成数组
[].push.call(arguments); //在后面添加一项
</code></pre>

<h3>3.2 类似继承</h3>

<p>借用别的方法放到，构建对象中。使对象也能借用到别的方法。</p>

<pre><code>var Add = function(a,b){
    return a + b;
}
var Del = function(a,b){
    return a - b;
}
var B =function(){
    this.add = Add.apply(this,arguments);
    this.del = Del.apply(this,arguments);
}
B.prototype.getAddNum = function(){
    return Add.apply(this,arguments);
    // 借用了Add方法，在对象中也有Add方法了。
}

var C  = new B(8,5);
console.log(C.getAddNum(9,2)); // 11
console.log(C.del);// 3
</code></pre>

<h3>3.3 应用实例</h3>

<h4>3.3.1 单例模式实现</h4>

<p>单例，简单来说就是，只是存在一个，不会出现两个，这个在弹出框的时候特别有用，这里牵涉到匿名函数，闭包，apply应用。</p>

<pre><code>var singleFn = function(fn){
    var rel;
    return function(){
        return rel || (rel = fn.apply(this,arguments));
        //如果有rel,则返回rel，如果没有则执行fn函数。
    }
}

var creatPopup = function(content){
    var popup = document.createElement("div");
    popup.style.display="none";
    popup.innerHTML = content;
    document.body.appendChild(popup);
    retuen popup;
}

var newCreatPopup = singleFn(creatPopup);

document.getElementById("show").onclick=function(){
    var popup = newCreatPopup("创建弹出框");
    //这里应用就是单例函数中return返回回来的函数
    popup.style.display = "block";
}
</code></pre>

<h4>3.3.2 函数执行顺序</h4>

<pre><code>Function.prototype.after = function(fn){
    var _self = this;
    //保存原有函数
    return function(){
        fn.apply(this,arguments);
        return _self.apply(this,arguments);
    // 返回原来函数执行结果
    }
}
Function.prototype.before= function(fn){
    var _self = this;
    return function(){
        var _s = _self.apply(this,arguments);
        fn.apply(this,arguments);
        return _s;
    // 返回原来函数执行结果
    }
}
var fn1 = function(){
    console.log(1);
}
var fn3 = function(){
    console.log(3);
}
var fn2 = function(){
    console.log(2);
}

var fnA = fn1.after(fn3).before(fn2);

fnA(); // 3,1,2
//这里先执行fn3,再到before方法中，这里首先执行fn1方法，再执行fn2
</code></pre>

<h2>四、总结</h2>

<p>使用apply或call，改变原有函数的上下文执行情况，要看当前函数执行的环境，在高级的函数使用中会经常用到apply概念。</p>


       
    </div>



    <div class="sidenav">
        <h2>语言</h2>
        <ul class="artical-list">
        
            <li><a href="/blog/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F">图片加载的几种方式</a>
            
            </li>
        
            <li><a href="/blog/promise">promise对象</a>
            
            </li>
        
            <li><a href="/blog/%E8%A3%85%E9%A5%B0%E6%80%A7%E6%A8%A1%E5%BC%8F">装饰性模式</a>
            
            </li>
        
            <li><a href="/blog/%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98">离线缓存(manifest)</a>
            
            </li>
        
            <li><a href="/blog/%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%90%8C%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F">async、defer、preload区别</a>
            
            </li>
        
            <li><a href="/blog/AngularJS%E5%AE%9E%E6%88%98-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5">AngularJS应用－基础概念</a>
            
            </li>
        
            <li><a href="/blog/AngularJS-%E6%8C%87%E4%BB%A4">AngularJS应用－指令</a>
            
            </li>
        
            <li><a href="/blog/Javascript%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0">学习笔记－设计模式 －函数</a>
            
            </li>
        
            <li><a href="/blog/Javascript%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0">学习笔记－设计模式－基础</a>
            
            </li>
        
            <li><a href="/blog/%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%80%83">模块化学习思考</a>
            
            </li>
        
            <li><a href="/blog/RequireJs%E4%BD%BF%E7%94%A8">RequireJs应用</a>
            
            </li>
        
            <li><a href="/blog/apply%E5%92%8Ccall">apply和call应用</a>
            
            </li>
        
            <li><a href="/blog/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81">表单验证－策略模式</a>
            
            </li>
        
            <li><a href="/blog/%E5%86%8D%E7%9C%8B%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0">再看返回函数</a>
            
            </li>
        
        </ul>

        <h2>工具</h2>
        <ul class="artical-list">
        
            <li><a href="/blog/ES6-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95">ES6 常用语法</a></li>
        
            <li><a href="/blog/webpack%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8">webpack使用方法</a></li>
        
            <li><a href="/blog/javascript%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83">前端规范的思考</a></li>
        
            <li><a href="/blog/jekyll%E4%BD%BF%E7%94%A8">jekyll基本使用方式</a></li>
        
        </ul>

        <h2>项目沉淀</h2>
        <ul class="artical-list">
        
            <li><a href="/blog/%E5%91%A8%E7%BA%AA%E5%BD%95">15年08月19日－周工作记录</a></li>
        
        </ul>
    </div>
</div>

<script src="/blog/js/post.js" type="text/javascript"></script>


    
</body>
</html>
