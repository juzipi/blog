---
layout: post
title: webpack使用方法
description: 主要记录一下，学习的情况，担心以后忘记
category: tool
---

## webpack基础使用

### 基本概念
也是一个脚手架工具，和原来的grunt和gulp作用相似，但是又有新的改进，更是现在因为react流行后，配合度最好的一个构建工具。

前端资源模块化管理和打包工具，（这里强调的是两个作用一个管理一个是打包），不要认为就是一个打包工具。

 - 将原来一些松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。
 - 可以按需加载模块进行代码分离，等到实际需要再异步加载
 - 通过loader的转换，任何形式的资源都可以视做模块，比如CommonJs模块、AMD模块、ES6模块、css、图片、josn、Less、Sass等。

一图胜万言，把官网的图拿过来

![webpack](https://raw.githubusercontent.com/juzipi/blog/gh-pages/_posts/tool/webpack.png)

把各种资源整合整合到最后，不管是js、css、图片，最后通过webpack输出成需要的文件。

实现按需加载

传统的构建工具，是把所有的模块，最终打包成一个build.js文件，而webpack可以异步的加载需要的资源。例如使用：Code Splitting。Alloytem团队： [按需加载](http://www.alloyteam.com/2016/02/code-split-by-routes/)

基本试用方法：

~~~
$ webpack --config XXX.js   //使用另一份配置文件（比如webpack.config2.js）来打包
 
$ webpack --watch   //监听变动并自动打包
 
$ webpack -p    //压缩混淆脚本，这个非常非常重要！
 
$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了

$ webpack --display-error-details  //方便出错时能查阅更详尽的信息，定位错误信息
~~~


### 现状

前端资源管理，一直都是一个比较难的难题，和后台管理不同，他面临的资源种类复杂，包括html、css、图片、js，这四样基本的东西，并且各自都交叉融合。

项目小的时候，还不能体现复杂性，当一个项目大的时候，就需要考虑模块化重复利用，特别是现在webapp，或者是单页应用越来越多的时候，按需加载这个需求就是必然会产生，手机端对于流量和页面渲染的速度要求更加高。

现在的js规范也有多种多样AMD、CMD、ES6等等，当项目上线的时候需要有一个能够整合所有gef

这也是这几年前端界一直都是在解决的问题，很早有百度的fis，现在有webpack。这也是这两年刚刚推出来的一个脚手架工具。

## 安装
需要先安装node才能，node自带npm管包工具。
	
	$ npm install webpack -g
> 全局安装

	$ npm install webpack --save-dev
> 安装到本文件夹，并且写入`package-json`文件中

## 快速使用
编译js文件

~~~javascript
//entry.js
document.write("first");
~~~
编译


	webpack entry.js module.js

	
会得到一个编译后的文件module.js，但是这是最简单的一种方式，一般真实的使用场景中是用配置文件来管理。下面就来看看配置文件怎么来做。

- /app
	* entry.js
	* module.js
- package.json
- webpack.config.js

上面是一个基本的实例文件分布，实际项目中要比这复杂的多，现在有入口文件 `entry.js`，需要加载的模块`module.js`，一个node的配置文件，一个webpack配置文件。

## 配置项
### 配置通用模块
有一些通用库，是不会改变，比如zepto这种，可以不用打包到bulid.js里面，并且构建的时候也能够节省时间，对于上线来说，可以减少文件的更新量。

~~~javascript
externals: {
   'zepto': 'Zepto'
 },
~~~
 
 然后再入口文件中引用

~~~html
<script type='text/javascript' src='//g.alicdn.com/sj/lib/zepto/zepto.min.js' charset='utf-8'></script>
~~~

模块中使用：

~~~javascript
var zepto = require("zepto");
console.log(zepto(document).height())
~~~

反过来说，如果有需要打包到bulid.js里面的js文件，这里就不用externals这个配置项，直接在页面中引用就好。

~~~javascript
require("../st/lib/zepto");  //注意路径
console.log($(document).height())
~~~

### output.filename 和 output.chunkFilename的区别

~~~javascript
{
    entry: {
        "index": "pages/index.js"
    },
    output: {
        filename: "[name].min.js",
        chunkFilename: "[name].min.js"
    }
}
~~~
chunkname是未被列在entry中，却又需要被打包出来的文件命名配置。什么场景需要呢？在按需加载（异步）模块的时候，这样的文件是没有被列在entry中的，如使用CommonJS的方式异步加载模块：

~~~javascript
require('moudel1');
~~~

### 调试地图
可以在浏览器中看到模块，和js位置
~~~javascript
devtool: "source-map",
~~~

### 插件
#### glify

~~~javascript
plugins: [
  new webpack.optimize.UglifyJsPlugin({ 
    //可以加入Uglify的compressor options
    compress: { 
      //去掉压缩过程中的提示
      warnings:false 
    },
    //可以指定哪些变量name不混淆，
    //如 except: ['require','jQuery']
    except: [], 
    output:{
      //是否保留注释,默认为false
      comments:true
    } 
  })
]
~~~

#### webpack.ProvidePlugin

~~~javascript
new webpack.ProvidePlugin({ 
    $: "zepto",
     zepto: "zepto"
}),
~~~

设置全局的模块，配合前面的，设置通用模块

~~~javascript
externals: {
   'zepto': 'Zepto'
 },
~~~

后面在页面里面直接用，不用var $ = require("zepto")；

~~~javascript
$(window.height());
~~~

#### 其他

~~~javascript
new webpack.NoErrorsPlugin(),
    // 报错但不退出webpack进程
 new webpack.optimize.OccurenceOrderPlugin(),
    // 为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的ID
~~~

#### 合并图片

~~~javascript
var SpritesmithPlugin = require('webpack-spritesmith');

plugins: [
    new SpritesmithPlugin({
      src: {
      //需要设置雪碧图文件夹
        cwd: './src/assets/sp/',
      //包含什么文件类型
        glob: '*.png'
      },
      target: {
      //合并后的图片
        image: './src/st/img/sprite.png',
        //引用的css
        css: './src/st/css/_sprite.scss'
      },
      apiOptions: {
      //在css中设置的图片路径
        cssImageRef: '../img/sprite.png'
      },
      spritesmithOptions: {
      //排序方式，该处是从上到下
        algorithm: 'top-down'
      }
    })
  ]
~~~

使用方法:
		
		//引入css文件
		@import '_sprite.scss';
		
		 .icon-error {
		 //该处$error是合并前，文件名
 		  @include sprite($error);
		 }
		

#### devtool
为解决打包后，soure map问题，webpack给出四种不同的等级，对于调试难度，这里在开发过程中建议用eval-source-map，即保证打包时间，又能够方便调试。
当然这里因项目不同而配置，有一些项目非常大，可以选择压缩速度最快的cheap-module-eval-source-map 

devtool选项  | 配置结果
--- | ---
source-map | 在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包文件的构建速度；
cheap-module-source-map  | 在一个单独的文件中生成一个不带列映射的map，不带列映射提高项目构建速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便；
eval-source-map | 使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。不过在开发阶段这是一个非常好的选项，但是在生产阶段一定不要用这个选项；
cheap-module-eval-source-map | 这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点；





